
<!DOCTYPE html>
<html>
<head>
  <title>C++</title>
  <meta name="C++" content="text/html; charset=utf-8;" />
  <script type="text/javascript" src="../../logbook.js"></script>

  <script src="../../logbook-mathjax-config.js" defer></script> 
  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" type="text/css" href="../../logbook.css" />
</head>

<body onload="loadChapter('');">  

  <div data-type="titlepage" pdf="no">
    <header>
      <h1><a href="../../index.html" style="text-decoration:none;">Logbook</a></h1>
      <p style="font-size: 18px;"><a href="../../pages/bio/jjwt.html">Jayson Wynne-Thomas</a></p>
      <p style="font-size: 14px; text-align: right;"> 
        Last modified <span id="last_modified"></span>.</br>
        <script>
        var d = new Date(document.lastModified);
        document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
      </p>
    </header>
  </div>
  
  <div id="main" class="sidebar1">
    <span style="font-size:10px;cursor:pointer" onclick="openNav()">&#9776;</span>
  </div>

  <div id="mySidenav" class="sidebar">
  
<a href="#0">Topics</a>
<a href="#1">Encapsulation & abstraction</a>
<a href="#2">Access specifier or modifier</a>
<ul class="no-bullets">
  <li><a href="#2.0">Members</a></li>
  <li><a href="#2.1">Inherited access specifiers</a></li>
</ul>
<a href="#3">Invariants - struct vs class</a>
<ul class="no-bullets">
  <li><a href="#3.0">When to be private</a></li>
</ul>
<a href="#4">Constructor</a>
<a href="#5">Scope resolution</a>
<ul class="no-bullets">
  <li><a href="#5.0">Class</a></li>
  <li><a href="#5.1">Namespace</a></li>
</ul>
<a href="#6">Inheritance</a>
<a href="#7">Friends</a>
<a href="#8">Miscellaneous</a>
</div>

<chapter style="counter-reset: chapter 0"><h1>C++</h1>

<section id="0"><h1>Topics</h1>
  <ul>
    <li>Memory (resource)</li>
    <ul>
      <li><a href="members.html">Memory/Member types and initialisation</a></li>
    </ul>
    
    <li>Memory management</li>
    <ul>
      <li><a href="beforeSmartPointers.html">Before smart pointers</a></li>
      <li><a href="raii.html">RAII</a></li>
      <li><a href="rawPointers.html">Raw pointers</a></li>
      <li><a href="smartPointers.html">Smart pointers</a></li>
    </ul>
    <li><a href="polymorphism.html">Polymorphism</a></li>    
    <li><a href="lambda.html">Lambda functions</a></li>
    <li>Standard library</li>
    <ul>
      <li><a href="vector.html">Vector</a></li>
    </ul>
  </ul>
</section>

<section id="1"><h1>Encapsulation & abstraction</h1>
  <i>Encapsulation</i> means that:
  <ul>
    <li>Related properties are bundled together in a single class</li>
    <li>These properties are protected from unauthorised or accidental modifications using <i>access modifiers</i></li>
  </ul>

  <p>
    <i>Abstraction</i> means that users of a class only need to be familiar with its interface, they don't have to know how member data are stored or how member functions are implemented. 
  </p>

  Encapsulation and abstraction are related because encapsulation groups relevant data together in a class, while abstraction hides the details of how the data is manipulated. All the user of a class needs to know is that the data is present and there is an interface to interact with it. 
</section>

<section id="2"><h1>Access specifier or modifier</h1>
  <subsection id="2.0"><h1>Members</h1>
    <ul>
      <li>Public members</li>
      Public members can be changed <n>directly</n>, by any user of the <i>object</i> (an instance of the class) [<a href="../../jlib/cppExamples/fundamentals/1_public.cpp">Ref</a>].

      <p>
      <li>Private members</li>
      [<a href="../../jlib/cppExamples/fundamentals/2_private.cpp">Ref</a>]. They are only accessible directly from within the class itself using member functions. One exception is that they are accessible from <n>friends</n>. 
      </p>

      <li>Protected members</li>
      [<a href="../../jlib/cppExamples/fundamentals/3_protectedMembers.cpp">Ref</a>]. They are accessible from member functions of the same class, from friends and also from member functions of derived classes.
    </ul>
  </subsection>

  <subsection id="2.1"><h1>Inherited access specifiers</h1>
    [<a href="../../jlib/cppExamples/fundamentals/11_inheritedAccessSpecifiers.cpp">Ref</a>] <br>
    The same access modifiers also define which class members users of derived classes can access.

    <ul>
      <li>Public inheritance</li>
      The derived class can access the public and protected members of the base class.

      <p>
        <li>Protected inheritance</li>
        The public and protected members of the base class become protected members of the derived class.
      </p>

      <li>Private inheritance</li>
      The public and protected members of the base class become private members of the derived class.
    </ul>
  </subsection>
</section>

<section id="3"><h1>Invariants - struct vs class</h1>
  [<a href="../../jlib/cppExamples/fundamentals/4_invariants.cpp">Ref</a>]

  <p>
    If we're just carrying publicly accessible data where all data members can vary independently of each other and don't really have any limitations, then a struct is preferred. When we need to make data members private or add limits on them (<i>invariants</i>), then the convention is typically to convert from a struct into a class. 
  </p>
  
  By default, all members of a struct default to public, whereas all members of a class default to private. 

  <subsection id="3.0"><h1>When to be private</h1>
    As a general rule, <n>member data subject to an invariant should be specified private in order to enforce the invariant before updating the member's value</n>.

    <p>
      To access private members, typically public <i>accessor</i> and <i>mutator</i> member functions (also called <i>getter</i> and <i>setter</i> functions) are used. A trivial getter or setter adds no semantic value; the data item could just as well be public [<a href="../../jlib/cppExamples/fundamentals/5_trivialGetterSetter.cpp">Ref</a>].
    </p>
  </subsection>
</section>

<section id="4"><h1>Constructor</h1>
  [<a href="../../jlib/cppExamples/fundamentals/6_constructors.cpp">Ref</a>]
  <br>
  Constructors are member functions of a class or struct that initialise/construct/build an object. All classes come with a default constructor which takes no arguments. But we can also define our own constructors so that there might be multiple different ways to instantiate an object of the class. 
  
  <p>
    Typically a constructor:
    <ul>
      <li>Initialises data members</li>
      <li>Establishes an invariant</li>
      <li>Acquires resources needed for an object to be used</li>
      (which are then typically released by a destructor)
    </ul>
  </p>

  It is not good to have any complex logic in a constructor in order to ensure that the constructor does not fail. It's hard to handle errors that take place within the constructor.
</section>

<section id="5"><h1>Scope resolution</h1>
  C++ allows different identifiers to have the same name, as long as they have different scope. For example, two different functions can each declare the variable int i, because each variable only exists within the scope of its parent function.

  <p>
    In some cases, scopes can overlap, in which case the compiler may need assistance in determining which identifier the programmer means to use. The process of determining which identifier to use is called <i>scope resolution</i>. <code>::</code> is the <i>scope resolution operator</i>. It is used to specify which namespace or class (scope) to search in order to resolve an identifier (a function name or a variable name).
  </p>

  <subsection id="5.0"><h1>Class</h1>
    Each class provides its own scope. The scope resolution operator becomes useful if we want to separate class declaration from class definition.
 
    <p>
      We might want to separate out the function definitions from the class declaration for various reasons. 
      
      <ul>
        <li>Maybe we only want to show the interface and not the actual implementation to potential users</li>
        <li>Maybe we want to split these into separate files</li>
      </ul>
    </p>
  </subsection>

  <subsection id="5.1"><h1>Namespace</h1>
    [<a href="../../jlib/cppExamples/fundamentals/7_namespace.cpp">Ref</a>]
    <br>
    Namespaces allow programmers to group logically related variables and functions together. Namespaces also help to avoid conflicts between variables that have the same name in different parts of a program. <code>std</code> is the namespace used by the C++ Standard Library. Classes like <code>std::vector</code> and functions like <code>std::sort</code> are defined within the std namespace.
  </subsection>
</section>

<section id="6"><h1>Inheritance</h1>
  The basic idea is to build on top of something else in a hierarchical structure preventing from having to re-define all of the common member variables.
  
  <p>
    Example: An apple class can be made the child of a fruit class. Apples have their own varieties, but they also inherit members from the parent fruit class like seeds. Going further, the fruit class might be a child of the plant class and might inherit some members from the plant class like mass. The plant class has a mass, so its child, the fruit class inherits this mass member, and therefore, the apple class which is the child of the fruit class also inherits the mass member from the plant class, through the fruit class, to the apple class.   
  </p>

</section>

<section id="7"><h1>Friends</h1>
  [<a href="../../jlib/cppExamples/fundamentals/12_friend_1.cpp">Ref</a>]
  <div class="container">
    <figure>
      <img style="height:100px; width:auto"
      src="../../figures/software/2_friendClass.png"/>
      <figcaption>
        Friend class
      </figcaption>
    </figure>
  </div>    
</section>

<section id="8"><h1>Miscellaneous</h1>
  <ul>
    <li>Default function arguments</li>
    [<a href="../../jlib/cppExamples/fundamentals/19_defaultFuncArgs.cpp">Example</a>]

    <p>
      <li><code>const</code> in a function declaration</li>
      [<a href="../../jlib/cppExamples/fundamentals/13_virtualFunction.cpp">Ref</a>] <br>
      It is a way to indicate that calling the function won't alter the internal data members of the object. It is a promise made by the function that it won't modify any non-static data members of the class it belongs to. A const member function can only call other const member functions and read data members of the object. It cannot modify the object's state in any way.
    </p>
  </ul>
</section>
</chapter>

</body>
</html>
