<!DOCTYPE html>

<html>

  <head>
    <title>Ch. 1 - Introduction</title>
    <meta name="Ch. 1 - Introduction" content="text/html; charset=utf-8;" />
    <link rel="canonical" href="https://jaysonthomas.github.io/interviewPrep.html" />

    <script type="text/javascript" src="../../../chapters.js"></script>
    <script type="text/javascript" src="../../../htmlbook/book.js"></script>

    <script src="../../../htmlbook/mathjax-config.js" defer></script> 
    <script type="text/javascript" id="MathJax-script" defer
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
    <script>window.MathJax || document.write('<script type="text/javascript" src="../../../htmlbook/MathJax/es5/tex-chtml.js" defer><\/script>')</script>

    <link rel="stylesheet" href="../../../htmlbook/highlight/styles/default.css">
    <script src="../../../htmlbook/highlight/highlight.pack.js"></script> <!-- http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html#language-names-and-aliases -->
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" type="text/css" href="../../../notes.css" />
  </head>

<body onload="loadChapter('manipulation');">

  <!-- The following division should be written on every page -->
<div data-type="titlepage" pdf="no">
  <header>
    <h1><a href="index.html" style="text-decoration:none;">Jayson's notes</a></h1>
    <p data-type="subtitle">Mostly control systems</p> 
    <p style="font-size: 18px;"><a href="http://people.csail.mit.edu/russt/">Jayson Thomas</a></p>
    <p style="font-size: 14px; text-align: right;"> 
      &copy; Jayson Thomas, 2020-2022<br/>
      Last modified <span id="last_modified"></span>.</br>
      <script>
      var d = new Date(document.lastModified);
      document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
    </p>
  </header>
</div>

<table style="width:100%;" pdf="no"><tr style="width:100%">
  <td style="width:33%;text-align:left;"><a class="previous_chapter"></a></td>
  <td style="width:33%;text-align:center;"><a href=../../../index.html>Table of contents</a></td>
  <td style="width:33%;text-align:right;"><a class="next_chapter" href=robot.html>Next Chapter</a></td>
</tr></table>

<!-- EVERYTHING ABOVE THIS LINE IS OVERWRITTEN BY THE INSTALL SCRIPT -->
<chapter style="counter-reset: chapter 0"><h1>Robotic Manipulation: Force control</h1>

<section id="table_of_contents"><h1>Table of Contents</h1>
  <ul>
    <li><a href="#1">Overview</a></li>
    <li><a href="#2">Task setup - decisions to be made</a></li>
    <li><a href="#3">System view</a></li>
    <li><a href="#4">Creating the model</a></li>
    <li><a href="#5">Testing the interaction of forces using the model</a></li>
    <li><a href="#6">Direct force control flip-up strategy</a></li>
    <li><a href="#7">Indirect force control</a></li>
    <li><a href="#8">Impedance control</a></li>
    <li><a href="#9">Remote centered compliance</a></li>
    <li><a href="#10">Questions & Todo</a></li>
  </ul>
</section>

<section id="1"><h1>Overview</h1>
  Our goal:
  <ul>
    <li>Come up with a strategy to flip up the box</li>
    <li>Reason about the contact forces</li>
    <li>Write a controller which means write some equations to be implemented as $u$</li>
  </ul>

  Here we'll be reasoning about a single finger. But there are lots of details about 
  how to derive the actual controller when it's the full robot. These details really 
  matter like the difference between a sensor that's high bandwidth, super clean and 
  implemented at a high frequency compared to something that's not is night and day. 

  <p>
    We can achieve direct force control using:
    <ul>
      <li>Force sensors at the wrist</li>
      <li>Acceleration sensors</li>
      <li>Making the quasi-static assumption</li>
    </ul>
  </p>
</section>

<section id="2"><h1>Task setup - decisions to be made</h1>
  <ul>
    <li>Choice of controller</li>
    <p>
    What do we want our core controller (the one running at the highest bandwidth
    i.e. the tightest control loop at the lowest level) to be.
    There are times where choosing to act like a force controller down at the lower level 
    (to close a loop on a force sensor) can be a better choice than trying to act
    like a position controller. Example, writing on a board.
    </p>
    <p>
      Another good example of something that's native in forces: 
      we want to push a book to the edge of a table. If you can rely on the assumption 
      that the friction forces between the hand and the book is larger than the forces 
      between the book and the table, then you need to put yourself in a regime where you're 
      not pushing too hard such that the book sticks on the table but you're also not pushing 
      too softly. We want to be in this nice regime where moving the hand moves the book on the 
      table. 
    </p>

    <li>Decisions related to modeling</li>
    <p>
      We're first going to assume the EE is a point (the point finger approximation) 
      and that we can perfectly control it.
      This abstraction means that we only come into contact with an object at one contact point.
      We don't have to worry about the complicated geometry of a finger.
      The finger is drawn as a sphere, but we'll think of it as a point.
      We'll take away the abstraction and add the robot back in later.
    </p>
    <p>
      The flip-up task is one that can be described naturally in the language of forces. 
      We'll model the forces between the box and the ground.  
      We specify contact points (yellow) 
      to make sure that when the simulation is run, the solver doesn't have to 
      arbitrarily pick points (where it computes the forces) on the box. 
      Those forces are going to have friction cones (at the points) which are a response to 
      gravity pulling down on the object when it is at rest. 
    </p>

    <figure>
      <img style="height:100px; width:auto"
      src="../../../figures/12_flipUpTask.png"/>
      <figcaption>
        Flip up task setup
      </figcaption>
    </figure>

    Once the box is tilted up, we're going to have contact forces on the back corner.
  </ul>
</section>

<section id="3"><h1>System view</h1>
  <figure>
    <img style="height:100px; width:auto"
    src="../../../figures/manipulation/5_forceControl_systemView.svg"/>
    <figcaption>
      System view
    </figcaption>
  </figure>

  In the systems view:
  <ul>
    <li>
      I've got a plant with $u$ coming in. The model equations are inside the plant.
    </li>
    <li>
      The force controller is going to take in $q$ and $\dot{q} potentially - 
      position and velocity of the finger if we're only doing force control on the finger. 
      But could also include that of the box. 
      It could also take in a desired force. 
    </li>
  </ul>

  <p>
    What else could we hand to the force controller?
    <ul>
      <li>Use a force sensor and provide measured force</li>
      A lot of robots trying to do force control type tasks, have an interesting arm 
      but they put a force torque sensor at the wrist. So they're only touching 
      the world and controlling forces through a specific force torque sensor. 

      <p>
        <li>Provide measured accelerations</li>
        If you don't have a force torque sensor you can potentially do some 
        of the same work by giving accelerations $\ddot{q}$. That's always a risky business 
        because you expect to be able to measure joint angles and velocities but measuring
        joint accelerations tends to give noisy signals unless they are measured
        directly. The aim is to keep the noise low. 
      </p>
    </ul>
  </p>
</section>

<section id="4"><h1>Creating the model</h1>
  The entire configuration space of the system, the $q$ vector has elements for both
  <ul>
    <li>The finger</li>
    Modeled as a point so don't have to worry about rotation.
    <li>The box</li>
    It's pinned down - so modeled as a 2D planar joint.
  </ul>

  $$q=\begin{bmatrix}x_{f}\\z_{f}\\x_{box}\\z_{box}\\\theta_{box}\end{bmatrix}$$

  The simulator implements the manipulator equation:
  $$
    M(q)\ddot{q} + C(q,\dot{q}) = \tau_g(q) + Bu + \Sigma_iJ_i^T(q)f^{c_i}
  $$
  There are 2 systems contributing to the manipulator equation, that are only connected
  through the contact forces. The mass matrix for instance would have entries for the 
  finger and the box. But they don't have any coupling terms (i.e. the diagonal terms are 0). 
  They're only coupled through the forces (3rd term RHS). If I'm not touching, 
  just wiggling the finger around, it doesn't do anything to the box i.e. 
  cause any accelerations on it.
  $$
    M(q) = \begin{bmatrix}
      fingerTerm & 0 \\
      0 & boxTerm 
    \end{bmatrix}
  $$

  <subsection><h1>Equations for the finger</h1>
    Let's write out the whole equation for the finger in the x coordinate:
    $$\begin{equation}
      m_f \ddot{x}_f = u_x + f^c_x
    \end{equation}$$
    The subscript f stands for finger. The force term isn't $f^{c_i}_x$ because
    there's only 1 contact hence only 1 force along x.

    We've chosen this scenario intentionally to be particularly simple. 
    It is assumed that we have a perfect torque/force source on the finger $u_x$ to move it
    [i.e. noise isn't modeled]. 
    The above eq. is just the 1st row of the manipulator equation in the x coordinate 
    i.e. the 2nd row considers the box. 
    It just happens gravity doesn't have any affect on the finger in the x direction, 
    so there's no contribution from the g term. It's a point mass, so there's no 
    coriolis term and the Jacobian is the identity matrix. 
    And of course, it leads us to just the free body F=ma equation.

    <figure>
      <img style="height:100px; width:auto"
      src="../../../figures/manipulation/4_forceControl.png"/>
      <figcaption>
        Free body diagram for the finger (pink) if it was only in contact with 
        the box in the x or z directions
      </figcaption>
    </figure>

    $$\begin{equation}
    m_f \ddot{z}_f = u_z + f^c_z - m_{f}g
    \end{equation}$$
    $f$ is positive in the eqs. because of the way we've aligned our right-hand rule 
    coordinate frame.
  </subsection>
</section>

<section id="5"><h1>Testing the interaction of forces using the model</h1>
  The goal of our force controller is to take a desired force in, 
  command a $u$ to be applied to the robot's finger in order to achieve a desired force out
  from it. Algebraically we can write this out and see if it makes sense.
  
  <subsection><h1>Quasi-static assumption</h1>
    <p>
      Let's assume we're in the mode of applying accelerations via the finger. 
      Let's also assume the finger is moving slowly and its accelerations are 
      effectively zero ($\ddot{x}==0$, $\ddot{z}==0$).
      Then any terms being contributed by the finger's inertial dynamics are small 
      compared to the contact force $f_{c}$, the applied force $u$ and gravity. 
      This idea is called making <i>quasi-static approximations</i> which we will
      use to start because it's easier. 
    </p>
    <p>
      Equations (1) and (2) would then be:
      $$u_x = -f^c_x$$
      $$u_z = -f^c_z + m_{f}g$$
    </p>
    <p>
      With the quasi-static assumption, given our desired contact forces, the controller output
      would be:
      $$\begin{equation}
      u_x = -f^{c_d}_x
      \end{equation}$$
      $$\begin{equation}
      u_z = -f^{c_d}_z + m_{f}g
      \end{equation}$$
    </p>
  </subsection>

  <subsection><h1>Applying a constant force via the finger</h1>
    <p>
      The forces of contact are actually coming from the interaction forces. 
      The physics engine is going to solve for some complicated relation to decide that.
      Let's think about the case of a constant force that is 0 in the z direction and 
      some positive constant greater than zero in the x direction:
      $$
        f^{c_d} = \begin{bmatrix}
                    c>0 \\
                    0
                  \end{bmatrix}
      $$

      <figure>
        <img style="height:100px; width:auto"
        src="../../../figures/manipulation/6_forceControl_notYetInContact.png"/>
        <figcaption>
          Applying force through the finger when it's not yet in contact.
        </figcaption>
      </figure>

      In many cases if we command a force and we're not actually making contact, 
      our controller is unjustified. The above controller 
      is expecting a reaction force, $f^{c}$. But it tends to do the right thing. 
      It will drive the finger into contact; the finger will move in the direction
      the force is being applied with some constant acceleration i.e. $m\ddot{x}=c$.
      Once in contact, then using (3,4) in a controller
      is a more reasonable attempt to try to regulate the contact force. 
      This is a very important point - a hallmark of force control.
    </p>
    <p>
      So, driving the finger to apply a force when there's no reaction force from a wall, 
      tends to drive the finger into contact if it's close to contact. 
      Walking robots are in (roughly) position control mode when swinging 
      because we'd like to get our foot to a particular position. But when it's 
      above the desired foot position, it goes into force control mode 
      (for the step and stance - staying there). This is good because if the terrain 
      is uneven, then the controller will still drive the robot's foot into the ground.
    </p>
  </subsection>

  <subsection><h1>Varying the constant horizontal force</h1>
    <figure>
      <img style="height:150px; width:auto"
      src="../../../figures/manipulation/7_forceControl_constantForce.png"/>
      <figcaption>
        Free body diagram of all the forces acting on the box/finger.
      </figcaption>
    </figure>
    We know there is/are:
    <ul>
      <li>some amount of horizontal friction force</li>
      <li>Normal forces that must match $m_{box}g$</li>
    </ul>

    If $c>0$, then the finger is going to accelerate into the box. 
    If $c$ is very small, the finger is light and it wouldn't have had enough time 
    to build up a lot of momentum, it could just get to the box and the box might just sit still. 
    That's the lowest regime. The box might move a bit due to some momentum effect 
    from the collision. 

    <p>
      If $c$ is 'very' large, the box is going to move until it slams into 
      the wall and will then stop. $c$ would have to be above the friction threshold 
      in this case. In the simulation, we could also have a regime where 
      the impact's enough to start the box moving but the drag is enough to slowly cause 
      it to decelerate to the point where the it comes to rest. 
    </p>
    <p>
      When the applied force is small i.e. accelerating slowly, it takes a while 
      in time to even make contact with the box. A plot, time vs x axis (distance) is made. 
      The contact is always made at the same x-axis point. If you go a little faster, 
      moves just a little bit more. It's still in the stiction regime. There's a regime 
      where you hit it and it'll start sliding but it'll come to rest. 
      And there's a regime where you just slam it into the back wall. Any bigger 
      force and the box will collide with the wall with a bigger impact.
    </p>
    <p>
      Are we assuming inelastic? We are not rigorously making that assumption. 
      There is a bit of bouncing because of some plasticity. In the simulation, a time stepping 
      method that allows a little bit of penetration and a soft contact model together 
      allows some bouncing. But if the finger does bounce, it is just going to push right 
      back in. 
    </p>
    <p>
      The model described by (3,4) assumes the box is pushing up against the wall 
      and it's not moving. Only when the box really isn't moving, are we going to get 
      the force that we expect out. In this state, if we push more, we'll get more force back. 
      That's only true at the limit when the box is pushed against the wall. But the 
      controller we got out of a very simple derivation can still be used to regulate 
      the force and do interesting things. 
    </p>
  </subsection>
</section>

<section id="6"><h1>Direct force control flip-up strategy</h1>
  <subsection><h1>Case where fine control is not available</h1>
    So, we want to flip up a box. I was originally going to shove it to the side and 
    then flip it. But how do we flip it up in its current location. It's pretty subtle. 
    To get the box into a regime where we're controlling the contact forces enough to 
    flip it up, there needs to be a lot of friction i.e. the friction cone needs to be
    bigger. The bigger friction cone allows us to have a bigger range of contact forces 
    to tip the box up. Normally, we would use our 2nd hand to help out friction 
    with a little bit of force on the opposite side of the box.
  </subsection>

  <subsection><h1>Case where fine control is possible</h1>
    If we know the friction coefficient and the robot can regulate/apply the contact forces 
    more accurately, then we can slide and tip the box.
    <figure>
      <img style="height:150px; width:auto"
      src="../../../figures/manipulation/8_forceControl_flipUp.png"/>
      <figcaption>
        Free body diagram of all the forces acting on the box/finger.
      </figcaption>
    </figure>

    Ideally, the only force we want on the LHS of the box is friction. 
    The finger will apply a force on the top RHS of the box.
    We have a friction cone (2, on the top RHS) based on the normal forces of the finger
    (it's equal and opposite force). 
    We're only allowed to apply forces within friction cone 2 otherwise the finger will 
    slip up the box (the box is a bit slippery). So the game becomes can you find a 
    force that stays inside friction cone 2 so there's just enough force within
    friction cone 1 to keep that point (LHS edge of the box) from slipping 
    and will cause the box to rotate up. 
  </subsection>

  <subsection><h1>Controller implementation</h1>
    Locally the flip-up strategy looks like a least squares problem and 
    the friction cone constraint can be locally approximated as a linear constraint.
    The whole derivation (a controller to flip the box up) is in the notes.

    <p>
      The controller we write is effectively thinking about a virtual angle. 
      We can parameterize the orientation of the box however we like 
      (here we do it w.r.t. some vertical). 
      We can implement a small PID controller that applies a force 
      (on RHS within friction cone 2). The desired virtual angle $\theta^{d}$
      is some angle that goes from the initial angle up to the top. 
      We try to follow this trajectory. The controller tracks $\theta^{d}$ with the 
      torque applied at an angle $\theta$ in the new simplified coordinates 
      (i.e. in terms of the virtual angle) being:
      $$\tau_{theta} = k(\theta^{d} - \theta) + b(\dot{\theta}^{d}-\dot{\theta})$$
      $\theta$ is the actual or the estimated angle.
    </p>
    
    <figure>
      <img style="height:150px; width:auto"
      src="../../../figures/manipulation/9_forceControl_VirtualAngle.png"/>
      <figcaption>
        The virtual angle in flipping up.
      </figcaption>
    </figure>      

    The controller tries to attain the closest torque possible to the commanded torque,
    subject to the friction cone constraints. So we try to follow the $\theta$ trajectory 
    up to some friction limits. If we start making $\mu$ small in the exercise notebook,
    at some point the controller won't be able to find a solution as the box will slip.
    In that situation, even a zero force would violate something. 
    This is all to do with the friction constraints.

    <p>
      The direction of the force applied by the finger would always want to be on 
      the friction cone or certainly there's a solution that would always want to be on the 
      friction cone. When it is on that friction cone, we are pushing both towards the 
      bottom LHS corner and around the top RHS to tip the box over. So there's some limit 
      based on the geometry (thresholds) of the friction cone at the LHS for which we 
      can achieve some rate. The faster the finger turns the box up, 
      at some point the box will slip.
    </p>

    The vertical component of the force that the finger applies on the RHS 
    (to tip the box up) contributes to the forces (along with the upward normal force at LHS) 
    fighting mg that is pulling downwards. So when we increase the force on the top RHS, 
    this reduces the friction cone at the bottom LHS. All these are in the equations. 
    These are all simple enough that the free body diagram is just completely written out. 
    Just be mindful the friction cone at LHS changes.
  </subsection>
</section>

<section id="7"><h1>Indirect force control</h1>
  Commanding forces only is potentially a limiting view of the world. 
  There's a class of models called <i>indirect force control</i> where we program 
  the force with an indirect objective. 

  <subsection><h1>Stiffness control</h1>
    One of the most powerful examples would be <i>stiffness control</i> - 
    instead of saying the goal is to regulate the contact force between the finger
    and the box, we make the finger act like a spring. So, if the finger was pushed on, 
    its response would be that of a spring.

    <p>
      The rest length of the spring is going to become the input to the control system. 
      If we want the finger to come into contact with the box and then potentially 
      move the box around, we can move the rest position of that spring into the box. 
      If the rest length was inside the box it would be applying a force to the box. 
      The force it would apply is proportional to how far into the box the rest length is. 
      This is an indirect way to command a force but it turns out to be super useful.
    </p>

    We want the finger to look like a spring mass damper system - 
    The equations will look like this:
    $$\begin{equation}
    m_f\begin{bmatrix}\ddot{x}_f \\ \ddot{z}_f\end{bmatrix}
    +b\begin{bmatrix}\dot{x}_f \\ \dot{z}_f\end{bmatrix}
    +k\begin{bmatrix}x_f-x^{d}_f \\ z_f-z^{d}_f\end{bmatrix}
    = f^c
    \end{equation}$$
    $z^{d}_f$, $x^{d}_f$ - virtual positions or rest length; the input to the 
    stiffness controller
    <p>
      Damping term: $b\begin{bmatrix}\dot{x}_f \\ \dot{z}_f\end{bmatrix}$,      
      Stiffness term: $k\begin{bmatrix}x_f-x^{d}_f \\ z_f-z^{d}_f\end{bmatrix}$
    </p>
    <p>
      If you put stiffness control and damping control together, it's 
      called <i>compliance control</i>.
    </p>
    <p>
      Whatever force the world is pushing on the finger (RHS), it will have a 
      well-defined response - it's going to act like a mechanical spring (LHS). 
      We are going to replace the dynamics of the robot with the dynamics of a spring. 
      This is a very important intuitive idea. One of the things that's very nice about 
      it is that springs are well behaved for any reasonable forces. If the world were 
      to come up and try to hit your resonant frequency, that would be bad! But if the 
      world is passive, energy conserving and the spring (the robot finger) is energy 
      conserving, then we have some guarantees that even if we don't know exactly what's 
      happening with the contact forces, things aren't going to go too bad.
    </p>
    <p>
      When each of the elements of the control system are passive, 
      then we can make guarantees about the stability of the entire system even 
      when they're in a complex composition. The elements could include the world 
      (if the world is energy conserving) and the robot (it could be energy conserving 
      or potentially even dissipative i.e. when it's got friction/damping terms 
      like the finger). There's a lot of deep literature on this <i>passivity-based 
      control</i>. It's a very powerful idea and there are a couple of references 
      in the notes about it - port hamiltonian theory takes this approach to an extreme.
    </p>
  </subsection>
  
  <subsection><h1>Stiffness control flip-up strategy demo</h1>
    <p>
      If we program the mechanics of our interaction, we can do something way 
      better than if we're trying to program the forces or the positions.
    </p>

    We didn't do teleop with force control because if we put a slider 
    and commanded the force, the demo would be very short because the finger 
    would either slam into something or go off the screen. But with stiffness 
    control we can move the set point of the spring around and do totally 
    reasonable things. In this demo, we make the box transparent because we're going to 
    stick our set point inside it. The gold finger is the set point and the aim of the 
    red finger is to track the gold finger. If the set point is only moved by a 
    short distance into the box, the force applied by the finger will be lower 
    than that of static friction and the box will not move.

    <figure>
      <img style="height:100px; width:auto"
      src="../../../figures/manipulation/10_stiffnessControl_flipUp1.png"/>
      <figcaption>
        Stiffness control flip-up strategy
      </figcaption>
    </figure>

    <p>
      The box will start moving all the way to the edge if we push harder 
      by moving the set point farther into the box. If rather than pushing at a right angle 
      into the box, we move the set point to an angle above the box, 
      the finger will start to lift the box. (still way into the box so that the finger is 
      still pushing into the box). This will cause a vertical component of the spring 
      force because the finger is trying to go towards the set point at an angle.
      The box won't rotate about the bottom LHS corner, but the top LHS corner.
    </p>
    <figure>
      <img style="height:100px; width:auto"
      src="../../../figures/manipulation/11_StiffnessControl_flippedUp.png"/>
      <figcaption>
        Stiffness control flip-up strategy
      </figcaption>
    </figure>
    <p>
      When the finger gets to the top, we are going to exceed the friction cone 
      on the LHS top corner. We are going to have no ability to push and stay inside 
      the friction cone. So the box is going to slip. In the previous model, we were 
      monitoring the forces/accelerations and trying to estimate the moment of that slip - 
      that's not a good way to go. If we wait to detect slip instantaneously 
      (incipient slip - signals right before slip) and then make a control decision, 
      we're not going to be successful in life. People try, but it's very hard.
    </p>
  </subsection>
  
  <subsection><h1>Philosophy of stiffness control</h1>
    If we can program the interaction in the right way, so that we're pulling on the 
    virtual set point or being pulled by it (it's a spring in between, pulling and 
    pushing) and we're in some reasonably chosen configuration, then:
    <ul>
      <li>The spring is going to push the finger into the wall</li>
      <li>The spring will tip both the box and the finger up</li>
      <li>
        The moment the box slips, we don't have to change the controller - 
        the finger is going to be pushing down. The set point is going to pull the 
        finger with it.
      </li>
    </ul>

    <p>
      This is a good strategy because large choices of the desired position, 
      damping and stiffness terms in (5) give very reasonable behaviours.
      Pushing the box into the corner solves the entire task; no detailed reasoning 
      about forces, no detailed estimation of friction contacts/cones is required. 
      We don't have to dial it in too carefully as in direct force control where 
      we had to be careful about the friction constraints.  
    </p>

    <p>
      This concept of programming the interactions/dynamics instead of the forces 
      directly is a paradigm shift and works well for different shapes, objects and tasks. 
      Classic tasks like wall following, welding, painting that are done by traditional 
      robotic arms are well suited to these kinds of controllers or vice versa. 
    </p>
  </subsection>

  <subsection><h1>Stiffness controller</h1>
    Looking at just the $z$ axis, if we implement the equation of motion given by (2)
    in the controller given by (5), the torque to be applied is given as:
    $$\begin{equation}
      u_z = -b\dot{z}_f - k(z_f - z^d_f) + mg
    \end{equation}$$

    This looks like PD control (first 2 RHS terms) for the point finger case plus 
    gravity compensation (the final RHS term). More generally, it looks like a bunch 
    of terms (gravity compensation in this case) that are trying to cancel out the 
    dynamics of the robot and replace them with the dynamics of a spring (first 2 RHS terms), 
    typically in the end effector's coordinates. 

    <p>
      If we had to do this with joints and act like a spring at the end point, 
      it's not going to be just a simple PD controller. It's going to be mapped 
      through some transformation to the joints. But if we master the robot's dynamics 
      then we can still control the end effector contact forces/interactions.
    </p>
  </subsection>
</section>

<section id="8"><h1>Impedance control</h1>
  <i>Impedance control</i> is a 'generalisation' of (6). In fact, (6) can be called
  an impedance controller. So far we just changed the stiffness and damping terms in 
  (5) and not the effective mass of the sphere. Even if we changed the mass 
  of our sphere, with a pretty simple controller as in (6) that doesn't have 
  to know too much, we can make the sphere act like a spring mass damper system 
  (as if it's got a spring attached to it).

  <p>
    If we have a real mastery of our robot's dynamics, we can even change the effect 
    of mass. So if someone were to push on the robot, even if it is very heavy, 
    we can make it act very light. That's a harder thing to implement. Depending on 
    how we implement it with acceleration or force terms, it can be subtle to get right. 
    It's also subtle to get right in terms of the bandwidth of the controller. So we could 
    use impedance control to mean stiffness control. Strictly the full glory of impedance 
    control is realised if we are also trying to change the mass. But, changing masses 
    is a nasty business. 
  </p>

  Iiwa doesn't do that. They tried to cancel the mass but the final controller just 
  doesn't do it. There's a different way to teach impedance control, but this is a 
  more intuitive way.

  <p>
    If we're trying to train an RL controller and have a choice between position, 
    impedance and torque commands; these are going to work very differently in the 
    training procedures. Knowing a few things about impedance control (when they work 
    and don't) is going to be useful for a lot of tasks that are contact rich.
  </p>
</section>

<section id="9"><h1>Remote centered compliance</h1>
  <subsection><h1>Peg-in-hole insertion task</h1>
    There was a canonical task created in the 80s called the peg-in-hole insertion task, 
    which motivated some great work in motion planning and control. So there is a 
    hole in the world and we've got a peg that's roughly the same size as the hole. 
    If we try to insert the peg into the hole with pure position control, it can be nasty.

    <figure>
      <img style="height:70px; width:auto"
      src="../../../figures/manipulation/12_rcc.png"/>
      <figcaption>
        Different configurations of the peg-in-hole insertion task
      </figcaption>
    </figure>

    <p>
      To solve this problem, it's okay to cheat a little bit. We chamfer the corners 
      of both the peg and the hole. If the peg is slightly out of alignment and we come 
      down without paying attention, we're going to get a very large contact force at 
      1 point (configuration 1). In configuration 2, we can actually get stuck with 
      large contact forces occurring at 2 points (it's an under-determined problem for 
      coulomb friction).       
    </p>
  </subsection>

  <subsection><h1>Peg-in-hole solution</h1>
    <figure>
      <img style="height:70px; width:auto"
      src="../../../figures/manipulation/13_rcc_translation.png"/>
      <figcaption>
        Translational stiffness
      </figcaption>
    </figure>
    It was decided early on that it pays to be in a force/compliant control mode. 
    Say, the robot is in position control mode and it has estimated things a 
    bit wrong and it's coming down with the peg; we'd like to have some horizontal 
    stiffness (a spring  horizontally) so that the controller slides a little bit 
    (horizontally) in order to go in. That's the translational version.

    <p>
      We can do stiffness control in orientation too - we can program a rotational 
      stiffness of the hand. We can solve the problem we had in configuration 2 by 
      programming rotational stiffness so that the robot hand aligns the peg itself 
      (after making the first awkward contact) and goes in. 
    </p>

    <figure>
      <img style="height:100px; width:auto"
      src="../../../figures/manipulation/14_rccInMiddle_rotation.png"/>
      <figcaption>
        Centre of rotation is in the middle of the vertical axis
      </figcaption>
    </figure>
    For rotational stiffness, we need to have a centre of rotation, some 
    coordinate frame to represent the rotation about. If we choose a rotational 
    stiffness around the centre of the peg, then when we do need to make a correction, 
    the peg will bend more at the opposite end to where the correction needs to be made. 
    In the figure, we want to rotate the top end of the peg more (grey orientation is 
    the desired). But, because the centre of rotation is in the middle, both ends rotate 
    an equal amount (yellow orientation is what happens).

    <figure>
      <img style="height:100px; width:auto"
      src="../../../figures/manipulation/15_rcc.png"/>
      <figcaption>
        Centre of rotation is at the end
      </figcaption>
    </figure>
    What we need instead is to have an effective centre of compliance that's at 
    the end point or even beyond the end. In the figure, the white axis is 
    the desired/correct orientation. This concept is called a 
    <i>remote centered compliance</i>. 
    It's really just a choice of where we parameterize our orientation. 
  </subsection>
</section>

<section id="10"><h1>Questions & Todo</h1>
  <ul>
    <li>
      I would love to be super comfortable with the manipulator equation
    </li>
    <li>
      What does it mean for a friction cone to be bigger (wider?) as 
      friction gets bigger?
    </li>
    <p>
      <li>Neville's lab teaches impedance control at MIT</li>
      Neville Hogan introduced this in the 1980s.
    </p>
  </ul>
</section>

</chapter>
</body>
</html>

