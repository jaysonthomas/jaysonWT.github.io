
<!DOCTYPE html>
<html>
<head>
  <title>Estimation</title>
  <meta name="Estimation" content="text/html; charset=utf-8;" />
  <script type="text/javascript" src="../../../logbook.js"></script>

  <script src="../../../logbook-mathjax-config.js" defer></script> 
  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" type="text/css" href="../../../logbook.css" />
</head>

<body onload="loadChapter('');">  

  <div data-type="titlepage" pdf="no">
    <header>
      <h1><a href="../../../index.html" style="text-decoration:none;">Logbook</a></h1>
      <p style="font-size: 18px;"><a href="../../../pages/bio/jjwt.html">Jayson Wynne-Thomas</a></p>
      <p style="font-size: 14px; text-align: right;"> 
        Last modified <span id="last_modified"></span>.</br>
        <script>
        var d = new Date(document.lastModified);
        document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
      </p>
    </header>
  </div>
  
  <div id="main" class="sidebar1">
    <span style="font-size:10px;cursor:pointer" onclick="openNav()">&#9776;</span>
  </div>

  <div id="mySidenav" class="sidebar">
  
<a href="#0">Introduction</a>
<ul class="no-bullets">
  <li><a href="#0.0">Definition</a></li>
  <li><a href="#0.1">The need for estimation</a></li>
  <li><a href="#0.2">Applications</a></li>
  <li><a href="#0.3">How to create an estimator</a></li>
</ul>
<a href="#1">Approaches to estimation</a>
<ul class="no-bullets">
  <li><a href="#1.0">3 Approaches to estimation</a></li>
  <li><a href="#1.1">Variable reference</a></li>
</ul>
<a href="#2">The problem of control with noisy measurements</a>
<a href="#3">Musings</a>
</div>

<chapter style="counter-reset: chapter 0"><h1>Estimation</h1>

<section id="0"><h1>Introduction</h1>
  <subsection id="0.0"><h1>Definition</h1>
    Estimation:
    <ul>
      <li>Is a temporal process - so you integrate things over time.</li>
      <li>
        It's a process of managing uncertainty. We can never be 100% certain 
        where the robot is.
      </li>
    </ul> 
  </subsection>

  <subsection id="0.1"><h1>The need for estimation</h1>
    To quantify uncertainty. The goal is to make a very tight distribution, 
    so that a robot is more certain of its state.
    The real world (bot and environment) is uncertain in the following ways:
    <ul>
      <li>
        It is stochastic. The effect of actions can have 
        uncertain outcomes due to intrinsic or extrinsic factors.
      </li>
      We might intend for a vehicle to follow a certain path, but it might
      get blown to one side by a gust of wind or suddenly stop working.
      This change in state is a source of uncertainty, we never know when it's 
      going to happen.
      <br><br>

      <li>
        It is only partially observable. There is uncertainty about 
        the current state of the world.
      </li>
      Where is the vehicle? What's behind that building over there? We can't
      know everything about the world.
    </ul>
  </subsection>

  <subsection id="0.2"><h1>Applications</h1>
    We only need sensor feedback if we want the drone to be autonomous. 
    To be autonomous, the robot needs to know the following (RHS of table). 
    Estimation plays a role in all these problems.
    <p><table class="table1 center">
      <tr>
        <th>Type of problem</th>
        <th>Knowledge of</th>
      </tr>
      <tr>
        <td>Localisation, navigation</td>
        <td>
          Itself
          <br>
          Where the vehicle is, its attitude  
          <br>
          How fast it's going
          </td>
      </tr>
      <tr>
        <td>Mapping</td>
        <td>
          The environment
          <br>
          What is around me?
        </td>
      </tr>
      <tr>
        <td>Tracking</td>
        <td>
          Others
          <br>
          Where are the other vehicles?
          <br>
          How fast are they going?
        </td>
      </tr>
    </table></p>
    E.g. estimation is what makes GPS work so well, Apollo spacecraft, 
    how the phone screen orients itself.
  </subsection>

  <subsection id="0.3"><h1>How to create an estimator</h1>
    We use <code>Bayes rule</code> which is a method:
    <ul>
      <li>To integrate data over time</li>
      <li>
        To take multiple sources of information, and come up with a distribution 
        that is the best reflection of what the state might be
      </li>
    </ul>
    Bayes rule relies on probability at its core to quantify uncertainty.
    There are other ways, such as confidence scores, fuzzy logic etc.
  </subsection>
</section>

<section id="1"><h1>Approaches to estimation</h1>
  The goal of estimation is to come up with an estimate $\hat{x}$ for some unknown state $x$, both of which are vectors. For a 2D quadrator moving in the vertical plane, this would be $y$, $z$, the roll angle $\phi$, and their corresponding derivatives.

  <p>
    In each of the below mentioned three approaches, we'll have three things:
    <div class="container">
      <figure>
        <img style="height:100px; width:auto"
        src="../../../figures/drone/25_estimationApproaches.png">
        <figcaption>
          The drone which is at a distance of $z$ from the ground, would get a laser range measurement of $\frac{z}{cos\phi}$ 
        </figcaption>
      </figure>
    </div>
  </p>
  
  <ul>
    <li>Measurement model $H$</li>
    A measurement model projects a state into measurement space. Let's say we had a 2D quadrotor with some true state vector $x$:
    $$
      x = \begin{bmatrix}y \\ z \\ \phi \\ \dot{y} \\ \dot{z} \\ \dot{\phi}\end{bmatrix}
    $$

    The drone is at some vertical position $z$ with a laser range finder pointing downwards. If it were a perfect sensor, it would measure a distance to the ground that's equal to $\frac{z}{cos\phi}$. In this case the measurement space is one dimensional. <n>$H$ is the function that maps a state to a measurement</n>:
    $$\begin{align*}
      Hx &= \begin{bmatrix} \frac{z}{cos\phi} \end{bmatrix} \\
      H &= \begin{bmatrix} 0 & \frac{1}{cos\phi} & 0 & 0 & 0 & 0\end{bmatrix}
    \end{align*}$$

    <li>Make $m$ measurements $y$ of true state $x$</li>
    $y$ represents a measurement. If they were perfect, we would get:
    $$
      y = Hx
    $$

    Each measurement will have some measurement noise:
    $$
      y = Hx + v
    $$

    <li>Mathematical model of noise</li>
    Since the measurements are imperfect, we need some model of the measurement noise $v$. This doesn't mean we'll know exactly how much noise gets added to each individual measurement; that will still be unknown. Rather, it means that we know the distribution from which this noise is sampled.

    $$
      v \sim N(0, R)
    $$
    
    Generally, we're going to model $v$ as a 0 mean Gaussian with some covariance $R$. So, where a perfect rangefinder would make some perfect measurement $Hx$, a realistic rangefinder would also add some zero mean Gaussian noise to each measurement.
  </ul>

  <subsection id="1.0"><h1>3 Approaches to estimation</h1>
  Each of the 3 approaches makes slightly different assumptions about the measurements and the underlying measurement model.

  <ul>
    <li>Least squares</li>
    The least squares approach, for example, requires that the measurements all come in all at once, and it assumes that the measurement model $H$ is an $n \times m$ matrix, which maps a state vector of length $n$ to a measurement vector of $m$ individual measurements.

    <p>
      Note that this means the measurement model must be linear, which wouldn't have worked for example earlier with the rangefinder since that measure model had a cosine in it. These are some pretty unrealistic assumptions, but this will be a useful starting point for discussing estimation.
    </p>

    <li>Recursive least squares</li>
    With the recursive estimator, measurements will come in one at a time. The measurement model will still be linear, but since measurements are coming in one at a time, $H$ will just be a vector, not a matrix, and this vector will map a state to a single measurement.

    <p>
      <li>Non-linear leasts squares</li>
      The non-linear least squares estimator is also recursive, which allows us to handle measurements coming in one at a time. But in this case, we'll allow the measurement model to be some arbitrary function of the underlying state.
    </p>
  </ul>
  To estimate the state of a vehicle, these approaches assume the vehicle is stationary. To incorporate motion into our state estimation process, we'll need to use the Kalman filter and its variants called the extended kalman filter and the unscented kalman filter. 
</subsection>

  <subsection id="1.1"><h1>Variable reference</h1>
  <table class="table1 center">
    <tr>
      <th>Variable</th>
      <th style="text-align:center">Meaning</th>
    </tr>

    <tr>
      <td style="text-align:center">$x$</td>
      <td>The unknown (and constant) state vector. This is what we're estimating!</td>
    </tr>

    <tr>
      <td style="text-align:center">$H$</td>
      <td>The (linear) measurement model. Perfect measurement of the state would yield $Hx$</td>
    </tr>

    <tr>
      <td style="text-align:center">$v$</td>
      <td>The noise which corrupts our measurements. It's sampled from a zero-mean normal distribution.</td>
    </tr>

    <tr>
      <td style="text-align:center">$R$</td>
      <td>The covariance of the measurement noise.</td>
    </tr>

    <tr>
      <td style="text-align:center">$m$</td>
      <td>The number of measurements made.</td>
    </tr>

    <tr>
      <td style="text-align:center">$n$</td>
      <td>The size of the state vector $x$.</td>
    </tr>

    <tr>
      <td style="text-align:center">$\tilde{y}$</td>
      <td>The actual noisy measurements.</td>
    </tr>
  </table>
</subsection>
</section>

<section id="2"><h1>The problem of control with noisy measurements</h1>
  We can capture the imperfections in a sensor using a <i>measurement model</i> which tells us $p(z|x)$:

  <p>
    $p(z|x)$ - The likelihood of making measurement $z$ given that we're in state $x$. Often, these measurement models are Gaussian. The most likely measurement is centred on the true value of whatever the sensor measures with some covariance.
  </p>

  We respect the <i>Markov Assumption</i> when our updated estimate only depends on the current observation and the previous estimate, i.e. it doesn't depend on all the previous observations used to find the previous estimate. 

  <p>
    We can use recursive averaging to compute the estimate. Recursive averaging would be better than taking batch averages because it requires less memory and we don't have to wait till we have all the measurements to make an estimate. But as $t$ gets bigger, new measurements are going to cause the estimate to change less and less, i.e. make the system less responsive. This method would be bad for a drone that hovers in place for a long time and then decides to move. The motion would take a long time to get incorporated into the estimate.
  </p>  

  $$\begin{align*}
    \hat{x}_t &= f(\hat{x}_{t-1}, z_t) \\
    \hat{x}_t &= \frac{t-1}{t}\hat{x}_{t-1} + \frac{1}{t}z_t
  \end{align*}$$
  
  A better technique would be the <i>exponential moving average</i>:

  $$\begin{align*}
    &\hat{x}_t = (\alpha)\hat{x}_{t-1} + (1-\alpha)z_t \quad\quad 0 \leq \alpha \leq 1
  \end{align*}$$

  <p>
    $x_t$ is the unknown state at timestep $t$. For a 1D drone, the state contains 2 elements: $x_t = \begin{bmatrix}z \\ \dot{z} \end{bmatrix}$
    <br>
    $\hat{x}_t$ is the estimate of the state at time $t$.
    <br>
    $z_t$ represents an observation or the measurement that we get at timestep $t$.
  </p>

  With exponential moving average, we have to make a trade-off (Imagine the drone-hover-then-move example and not just in terms of stationary measurements with small changes). If $\alpha$ is close to 1, i.e. $\alpha \approx 1$:
  <ul>
    <li>Trust previous estimate over new observations</li>
    <li>Robust against bad measurements</li>
    This leads to smooth estimates of state, which is good if the state actually is smooth. But when the state is not constant, this breaks down and the estimate is slow to respond to new measurements.
    <p>
      <li>Not responsive for fast motion</li>
    </p>
  </ul>

  If $\alpha \approx 0$:
  <ul>
    <li>Trust measurements over previous estimate</li>
    <li>Responsive to state changes</li>
    <li>Not robust against bad measurements</li>
  </ul>
</section>

<section id="3"><h1>Musings</h1>
  <ul>
    <li>Normalisation of data</li>
    <a href="https://t.ly/C0lw">Ref1</a>, 
    <a href="https://t.ly/q8JJ">Ref3</a>.
    <li>Absolute vs relative tolerance</li>
  </ul>

  <a href="https://t.ly/WRZn">Great resource</a> on Kalman and bayesian filters. There is also an introduction to statistics course on Udacity.
</section>

</chapter>

</body>
</html>
