
<!DOCTYPE html>
<html>
<head>
  <title>Arm kinematics</title>
  <meta name="Arm kinematics" content="text/html; charset=utf-8;" />
  <script type="text/javascript" src="../../../../logbook.js"></script>

  <script src="../../../../logbook-mathjax-config.js" defer></script> 
  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" type="text/css" href="../../../../logbook.css" />
</head>

<body onload="loadChapter('');">  

  <div data-type="titlepage" pdf="no">
    <header>
      <h1><a href="../../../../index.html" style="text-decoration:none;">Logbook</a></h1>
      <p style="font-size: 18px;"><a href="../../../../pages/bio/jjwt.html">Jayson Wynne-Thomas</a></p>
      <p style="font-size: 14px; text-align: right;"> 
        Last modified <span id="last_modified"></span>.</br>
        <script>
        var d = new Date(document.lastModified);
        document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
      </p>
    </header>
  </div>
  
  <div id="main" class="sidebar1">
    <span style="font-size:10px;cursor:pointer" onclick="openNav()">&#9776;</span>
  </div>

  <div id="mySidenav" class="sidebar">
  
<a href="#0">Topics</a>
<a href="#1">Overview</a>
<ul class="no-bullets">
  <li><a href="#1.0">Basic strategy</a></li>
</ul>
<a href="#2">Frames for pick and place</a>
<ul class="no-bullets">
  <li><a href="#2.0">Timing between key frames</a></li>
</ul>
<a href="#3">Interpolation between poses</a>
<ul class="no-bullets">
  <li><a href="#3.0">Interpolation between positions</a></li>
  <li><a href="#3.1">Problems faced when interpolating between orientations</a></li>
  <li><a href="#3.2">The right way to interpolate between orientations</a></li>
</ul>
<a href="#4">The controller</a>
<ul class="no-bullets">
  <li><a href="#4.0">Limitations</a></li>
</ul>
<a href="#5">Summary of the usefulness of optimisation</a>
<a href="#6">Example</a>
<a href="#7">Closing remarks</a>
<ul class="no-bullets">
  <li><a href="#7.0">QP formulation 1</a></li>
  <li><a href="#7.1">QP formulation 2</a></li>
  <li><a href="#7.2">Comparison of the 2 formulations</a></li>
</ul>
</div>

<chapter style="counter-reset: chapter 3"><h1>Arm kinematics</h1>

<section id="0"><h1>Topics</h1>
  <ul>
    <li><a href="notations.html">Notations</a></li>
    <li><a href="spatialVelocity.html">Spatial Velocity</a></li>
    <li><a href="fk.html">Forward Kinematics</a></li>
    <li><a href="diffIk.html">Differential Inverse Kinematics</a></li>
    <ul>
      <li><a href="pinv.html">Pseudo Inverse Jacobian</a></li>
      <li><a href="diffIkOpt.html">Differential IK as optimisation</a></li>
    </ul>
    <li><a href="singularities.html">Singularities</a></li>
  </ul>
</section>

<section id="1"><h1>Overview</h1>
  <ul>
    <li>Getting the notations right</li>
    Even in deep neural networks (say to calculate pose estimation), we're going to have a kinematics problem at some point and we're going to have a bug where the vectors are pointing the wrong way etc. If we get the notations right, spatial algebra will protect us.

    <p>
      <li>Choosing our frames</li>
      We have a gripper and a gripper frame; an object and an object frame. To grasp, we need to get the gripper frame in the right relative orientation and position to the object frame. 
    </p>

    <li>Trajectory generation</li>
    We'll plot the frames (the sketch) for the open-loop trajectory with the aim of the gripper picking up and dropping off a brick at a desired location. We forget the rest of the robot and just decide the different trajectory of poses the hand needs to go through in space at different timestamps; and then fill it out with interpolation.

    <p>
      <li>Inverse kinematics</li>
      We map the gripper plan sketch to moving the whole arm.
    </p>
  </ul>

  <subsection id="1.0"><h1>Basic strategy</h1>
    We have designed the gripper poses as a function of time using a trajectory generator and our aim is obtain corresponding joint positions as a function of time:

    $$
      X^G(t) \rightarrow q(t)
    $$

    The controller takes joint positions as input so we need to go from EE coordinates to joint commands. We start with a $q(0)$ and integrate forward using the joint velocity for that instant. The joint velocity is obtained by taking the inverse jacobian of the spatial velocity:

    $$
      \dot{q}(t) = [J^G(q)]^{-1}V^G(t)
    $$
    $V^G(t)$ is the spatial velocity of the gripper as a function of time.

    <p>
      We need to make sure the matrix is invertible or address it with more sophisticated methods. But intuitively we're going to design controllers that use the derivative of the kinematics (jacobian is approximately the derivative of FK) to get the smoothness in joint position transitions from one time instant to the next. 
    </p>

    We want to convert the smooth trajectory in EE coordinates to a smooth trajectory in the joint space, avoiding kinematic sigularities.

    <p>
      Summary: Use the reference trajectory to get $V_G$. Use Jacobian to get $\dot{q}$ which helps us to get $q(t)$ (integrating our way from q(0)) which is fed in as input. We need to avoid singularities by ensuring the Jacobian is invertible.
    </p>
  </subsection>
</section>

<section id="2"><h1>Frames for pick and place</h1>
  <table class="table1 center">
    <tr>
      <th>Object frames</th>
      <th>Gripper frames</th>
    </tr>
    <tr>
      <td>$O_{initial}$, $O_{goal}$</td>
      <td>$G_{initial}$, $G_{pick}$
        <br>
        $G_{prepick}$, $G_{postpick}$
        <br>
        $G_{place}$
        <br>
        $G_{preplace}$, $G_{postplace}$
        <br>
        $G_{clearance}$</td>
    </tr>
  </table>

  The numerical representation for a frame, say $O_{initial}$ on disk is its pose -  $^WX^{O_{initial}}$. A frame defines the semantics of whether we can connect 2 poses. But a pose is the manifestation that holds the position and orientation of a frame relative to some other frame. A frame cannot be represented because we have to somehow make a pose relative to something else.

  <p>
    Representing the pose of an object relative to the gripper or vice-versa is the most simple/robust representation commonly used for picking an object.
  </p>

  We interpolate from some initial gripper pose to a pose with the right clearance above the object to guarantee any collision is avoided. People do lots of interesting complicated algorithms to figure out how to move through space and just hand code the last movement often to avoid collision. 

  <p>
    To define the position of the gripper to move into to pick an object, pick whatever direction (in terms of axis) is the easiest relative to the object. A similar thinking applies to orientation. For this, it would be good to know what orientation the object is in. For a little red cube, it is hard to get its orientation from a perception system because it's symmetric. Then we get our pose $^{G_{pick}}X^{O_{initial}}$. We do the same for pre/post pick etc.
  </p>

  <subsection id="2.0"><h1>Timing between key frames</h1>
    Sometimes the time to finish a segment between going from 1 key frame to another, is absolute. Sometimes, it's scaled based on the distance between the frames. 
  </subsection>
</section>

<section id="3"><h1>Interpolation between poses</h1>
  We need to interpolate between the key poses to figure out where the gripper needs to be at all times between the pick and place frames.

  <subsection id="3.0"><h1>Interpolation between positions</h1>
    <p>
      Say, we had the following plot:
      <ul>
        <li>X-axis: time.</li>
        We can specify when the pick and place should take place and all the other intermediate frames specified in time.

        <p>
          <li>Y-axis: ${^WP^G_{W_x}}$</li>
          The position of the gripper in the world frame is a 3 element vector but we only consider the x component.
        </p>
      </ul>
    </p>

    <div class="container">
      <figure>
        <img style="height:80px; width:auto"
        src="../../../../figures/manipulation/39a_positionInterpolation.png"/>
        <figcaption>
          Key frames between pick and place times
        </figcaption>
      </figure>
      <figure>
        <img style="height:80px; width:auto"
        src="../../../../figures/manipulation/39b_positionInterpolation.png"/>
        <figcaption>
          First order interpolation
        </figcaption>
      </figure>
      <figure>
        <img style="height:80px; width:auto"
        src="../../../../figures/manipulation/39c_positionInterpolation.png"/>
        <figcaption>
          Zero order hold
        </figcaption>
      </figure>
    </div>

    There are different ways of interpolating:
    <ul>
      <li>First order hold</li>
      It's called first order because the line joining 2 points has 1DOF i.e. the slope of the line. It's a simple straight line interpolation. Doing a first order interpolation for orientation requires a bit more care compared to doing it for positions.

      <p>
        <li>Zero order hold</li>
        Zero order hold would be if there was no interpolation between the points and we just did some staircase. It is not safe to run this on a robot.
      </p>
      
      <li>Higher order interpolations</li>
      They give nice curves between key poses.
    </ul>
  </subsection>
  
  <subsection id="3.1"><h1>Problems faced when interpolating between orientations</h1>
    <subsubsection><h1>Choice of representation</h1>
      Some representations look simple to interpolate but then would blow up - could potentially go through bad states in the middle. 

      <p>
        There are roll pitch yaw values that represent very similar orientations but are actually very far in the values. Trying to go between one and another representation of roll pitch yaw might take the robot through extremely large numbers. This goes along with gimbal lock. 
      </p>
    </subsubsection>

    <subsubsection><h1>Simple linear interpolation for orientations is not possible</h1>
      Let's take a simple 2D rotation matrix example. We have a 2D rotation written as a function of some angle $\theta$ which will rotate a $2 \times 1$ vector by $\theta$ degrees:
      $$
        R(\theta) = \begin{bmatrix}
        c\theta & -s\theta \\
        s\theta & c\theta
        \end{bmatrix}
      $$

      Let's say we have 2 rotation matrices for rotating by $90^0$ and the other by $0^0$.
      $$
        R(0) = \begin{bmatrix}
        1 & 0 \\
        0 & 1
        \end{bmatrix} \quad
        R(\frac{\pi}{2}) = \begin{bmatrix}
        0 & -1 \\
        1 & 0
        \end{bmatrix}
      $$

      <div class="container">
        <figure>
          <img style="height:80px; width:auto"
          src="../../../../figures/manipulation/40a_0rotation.png"/>
          <figcaption>
            Rotation of a unit frame <code>Rotz(0)</code>
          </figcaption>
        </figure>
        <figure>
          <img style="height:80px; width:auto"
          src="../../../../figures/manipulation/40b_90rotation.png"/>
          <figcaption>
            Rotation of a unit frame <code>Rotz(90)</code>
          </figcaption>
        </figure>
      </div>
      If we were to linearly interpolate between the 2 angles, we wouldn't get $45^0$ i.e. we'd get $\frac{1}{2}$s in the rotation matrix instead of $\frac{1}{\sqrt{2}}$s. We can't just interpolate orientations.
    </subsubsection>

    <subsubsection><h1>Why don't we have such problems with angular velocities</h1>
      Angles wrap around every $2\pi$ and velocities don't. If we rotate by $\pi$, $-\pi$ or $3\pi$, we'll end up at the same place. But $100rad/s$ is still different than every other positive radian per second.

      <p>
        In 2D, you can represent everything with a scalar, a single rotation. When the wrapping effect is seen, flip back from polar coordinates or rectangular coordinates and we can always figure out the angles between two locations. In 2d, if we think about a rotation taking us around a unit sphere - a point moving around the unit sphere, the angular velocity is just the tangent on that and it's well behaved.
      </p>
 
      In 3d, there are rotations/angles that we can get to from many paths and picking a unique inverse of it is messy. 
    </subsubsection>
  </subsection>

  <subsection id="3.2"><h1>The right way to interpolate between orientations</h1>
    People typically use:
    <ul>
      <li>The quaternion representation to get around gimbal lock</li>
      <li><i>SLERP (Spherical linear interpolation)</i> to get a smooth first order interpolation</li>
    </ul>
  </subsection>

</section>

<section id="4"><h1>The controller</h1>
  <div class="container">
    <figure>
      <img style="height:60px; width:auto"
      src="../../../../figures/manipulation/41_pseudoInverseController.png"/>
      <figcaption>
        $\dot{q}^d$ is desired IIWA velocities, $V^{G^d}$ is desired spatial velocities.
      </figcaption>
    </figure>
  </div>

  To compute the desired velocities, the pseudo inverse controller (PIC) needs:
  <ul>
    <li>a model of the robot (inside the block)</li>
    <li>current positions of the robot $q$</li>
    We could use the commanded/desired or the measured position. The latter could be noisy so it's more stable to use the former.

    <p>
      If actual positions were used instead, even in simulation, we'd get a good solution but then in the <i>null space</i> (in the multiple solution dimension) the elbow will walk around a little. It's a subtlety of the way these things feedback with the numerical precision of the integrator.
    </p>

    <li>commanded desired spatial velocities $V^{G^d}$</li>
  </ul>

  PIC takes in commanded poses and outputs commanded joint positions (integrator included). The manipulation station takes in desired position commands (not velocities), so we need an integration step to turn desired velocities into position commands. The initial conditions of the integrator need to match that of the robot, else the robot will go to a very bad initial condition at time zero. 

  <p>
    The manipulation station outputs the actual/measured iiwa positions. The trajectory generator converts the planned sketch into a spatial velocity trajectory. It feed into the PIC, which feeds into the integrator which feeds the manipualtion station.
  </p>

  <subsection id="4.0"><h1>Limitations</h1>
    The chapter's notebook has sliders that rotates the joints of the arm which then changes the Jacobian, which is printed.

    <p>
      If there are no solutions, the controller will come up with the best possible solution. It will find the minimum norm. When is it not enough? At a singularity. What does a singularity mean? 
    </p>

    <button class="accordion">Matrix rank</button>
    <div class="panel">
      <p></p>
      The <i>rank of a matrix</i> is the maximum number of linearly independent rows or columns in that matrix. In robotics, the <i>rank of a matrix</i> is used to determine the <i>manipulability</i> or <i>controllability</i> of a robot arm. It indicates the number of independent directions in which the end-effector of the arm can move. The <i>rank of the Jacobian matrix</i>, which relates the joint velocities to the end-effector velocities, provides valuable information about the arm's mobility and its ability to reach different positions and orientations in its workspace.

      <p>
        If the rank of the Jacobian matrix is equal to the number of DOF of the robot arm, it means that the arm can move freely in all possible directions within its workspace. This implies that the robot arm is fully controllable and can reach any desired position and orientation within its reachable workspace.
      </p>
      
      On the other hand, if the rank of the Jacobian matrix is less than the number of DOF, it suggests that the arm is kinematically constrained. This can occur when certain joints of the arm are mechanically linked or when there are other physical limitations that restrict the arm's movement. In such cases, the arm may have limited mobility and may not be able to reach all desired positions and orientations in its workspace.

      <p>
        In summary, the rank of a matrix, particularly the Jacobian matrix, provides insight into the controllability and mobility of a robot arm. A higher rank indicates greater freedom of movement, while a lower rank suggests constraints or limitations on the arm's motion.
      </p>
    </div>

    When the arm changes from having good solutions to having no or infinite solutions, there is the possibility of the rank of the matrix $[J^B(q)]^{-1}_{\scriptscriptstyle{6\times{7}}}$ to drop. Since we are trying to find $q$, we only care about the row rank. It is a good case, when we have 7 $\dot{q}$s and only 6 desired velocities, since we have multiple solutions. We never want the rank to drop below 6.

    <p>
      A robot will break before it drops rank. What actually happens is, as the robot approaches losing rank the inverse gets poorly conditioned and we'll get very big commanded velocities out which will cause the robot to hit a joint or velocity limit and it'll shut down.
    </p>

    The relative distance (numerically) between the smallest and largest singular value is not what matters. If the smallest singular value gets close to 0, we'd get large velocities on inverting the matrix. So it's useful to plot the smallest singular value. 
    
    <p>
      One easy way to get the arm in a singular state is to straighten it. There could be other singularities. When an arm is pretty extended and we try to extend it more, things are going to get bad.
    </p>

  </subsection>
</section>

<section id="5"><h1>Summary of the usefulness of optimisation</h1>
  To get more robust Jacobian based controllers, we need to use a richer language (i.e. give it more details of the robot). For example, we say, find the desired spatial velocity that is as close as possible to the minimum but respects the joint/acceleration/velocity limits of the robot. 

  <p>
    The 3 main pieces of drake:
    <ul>
      <li>The systems framework</li>
      <li>The multibody plant</li>
      <li>Mathematical programs</li>
    </ul>

    Mathematical programs make it really easy to write optimisation problems and connect it to the other two pieces. Drake is a language that provides this framework - we can say I'm going to make a new optimization problem or a mathematical program. <i>Mathematical programs</i> are slightly bigger than optimisation. It doesn't need to have an objective. If it's a feasibility problem with no objective you can study mathematically. 
    
  </p>

  For an optimisation problem, in drake, we can:
  <ul>
    <li>Declare the decision variables $x$</li>
    <li>Add constraints</li>
    <li>Add cost function</li>
    <li>Solve to get the solution as the output</li>
  </ul> 
</section>

<section id="6"><h1>Example</h1>
  In <code>qp_diff_ik.ipynb</code>, the Kuka is turned into a 2d version. Only 2 joints are active to make it as similar as possible to the 2 link pendulum example. It plots the quadratic cost function in the 2 variables (in green) which is the optimization problem given by the Jacobian $\|J^{G}(q) \dot{q}-V^G\|^2$ subject to a few constraints on velocities. The constraints are in red. The optimal solution is represented by a green blob. 

  <p>
    The arm moves back and forth through the singularity. When the arm is straight, the bowl goes completely flat (if our viewing angle is set correctly, we can see it). It goes flat depending on how quickly the code integrates, but it gets broader and broader. Already in this configuration, the solution looks a little dicey up against the velocity limit. The arm has a tilt to it too, so the optimal solution would have been a very large velocity but the constraints keep us safe. 
  </p>
</section>

<section id="7"><h1>Closing remarks</h1>
  Q: What if the actual constraints are not linear? We can choose to solve a harder optimisation problem but the standard choice is linear. For instance the joint limits actually would be a nonlinear function in general. But we approximate it with an euler approximation which makes it a linear constraint. Position and acceleration limits are actually linear for any euler kind of integration step. Torque limits are not linear. The linearization for the latter is a bit tricky but we tend to not do torque limits. 

  <p>
    The idea of optimisation and quadratic programming is such a powerful framework and we're going to use it more. This is just a quick introduction. 
  </p>

  The worst case is when the robot is up against a limit on one joint. For instance, the second joint moves along as if nothing happened and the first joint changes which means the hand is going off in the wrong direction. We're going to eventually have feedback loops coming through this whole system and that's what's going to save us. But even in this open loop framework because we know about where the limits are, we can plan for them without any direct feedback and we can at least do a better best effort in the beginning. 

  <p>
    For instance, the way that we actually run the robot is we don't run it to be as close as possible to our desired velocity in the least squares sense. We actually do a slightly different objective. We have some desired velocity. We pick joint angles that will move the hand in the direction of that velocity. When a limit is hit we scale down the whole velocity but keep the direction the same; because we don't want our robot walking away from the desired trajectory. This is a richer formulation but we can still make it work as a quadratic program. 
  </p>

  <subsection id="7.0"><h1>QP formulation 1</h1>
    Find $\dot{q}$ such that $J^G(q)\dot{q} \approx V^G$.

    $$\begin{align*}
      min_{\dot{q}} \quad &\|J^G(q)\dot{q} - V^G\|^2 \\
      s.t. \quad & \|\dot{q}\| \leq \dot{q}_{max} \\
          & \text{joint/acceleration limits etc.}
    \end{align*}$$
  </subsection>

  <subsection id="7.1"><h1>QP formulation 2</h1>
    This is a slightly different formulation which says constrain the arm to move only in the desired direction of the gripper. We're going to maximise a linear objective. This is actually a simpler program.

    $$\begin{align*}
      max_{\dot{q}, \alpha} \; & \alpha \\
      s.t. \quad & J^G(q)\dot{q} = \alpha V^G \\
          & 0 \leq \alpha \leq 1 \\
          & \text{joint velocity/acceleration/position limits}
    \end{align*}$$

    $\dot{q}$ (vector), $\alpha$ (scalar) are the decision variables. The objective though is only in terms of one of the decision variables; the aim is to make the scalar $\alpha$ as big as possible (maximise) subject to the above conditions. The desired spatial velocity is a vector which is allowed to be scaled by $\alpha$, but we must choose a $\dot{q}$ on the LHS that matches some scaled version of that vector. 

    <p>
      Even though $\dot{q}$ is not part of the objective, we still need to define a solution for it because it enters in via the equality constraint. So $\dot{q}$ can only live on the set of possible $\dot{q}$s such that $\dot{q}$ times the current Jacobian (LHS) moves the EE in the direction of the desired spatial velocity (RHS)! If $\alpha$ is arbitrary, then if we have one $\dot{q}$ that's a solution, we could multiply it by two and it would still be a solution. 
    </p>

    So basically, we take the $\dot{q}$ that will achieve the objective without any constraints and then scale it down - shrink all of the joint velocities by the same scaling in order to satisfy the constraints. So now the arm will always move in the desired direction - it would rather stop completely when deviating.

    <p>
      This is what's happening inside the differential IK. This differential IK controller was used in the first teleop notebook. One will get a lot of mileage out of this method in the class. It takes in poses, does the differentiation and integration and runs this kind of control. 
    </p>
  </subsection>

  <subsection id="7.2"><h1>Comparison of the 2 formulations</h1>
    Between the 2 methods, we only changed what we want as a degradation in performance. When we have to give up performance, we can choose what we give up. In the 1st case we are after a spatial velocity as output that's as close as possible in the least squares sense to the desired spatial velocity. In the 2nd case we are willing for it to be less close in the numbers as long as it stays constrained in the right direction. So it's just a different choice of how we are okay for it to degrade when it can't satisfy the constraints perfectly. 

    <p>
      What happens if there were no constraints? In the 2nd case, it's going to choose $\alpha = 1$ and it's going to make $\dot{q}$ exactly equal to the spatial velocity. So it'll solve the problem exactly. And as the constraints become active because the arm might be running up against them, then $\alpha$ will have to shrink and that can be considered as a very graceful degradation.
    </p>

    In the 1st case if there are no limits, again it'll find $\dot{q}$ exactly to drive the objective to zero. As the constraints come on, it will find a different velocity but it might make the arm move in the wrong direction. We get to specify how we want it to degrade. 
  </subsection>

</section>
</details>
</chapter>

</body>
</html>
