
<!DOCTYPE html>
<html>
<head>
  <title>Arm kinematics</title>
  <meta name="Arm kinematics" content="text/html; charset=utf-8;" />
  <script type="text/javascript" src="../../../../logbook.js"></script>

  <script src="../../../../logbook-mathjax-config.js" defer></script> 
  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" type="text/css" href="../../../../logbook.css" />
</head>

<body onload="loadChapter('');">  

  <div data-type="titlepage" pdf="no">
    <header>
      <h1><a href="../../../../index.html" style="text-decoration:none;">Logbook</a></h1>
      <p style="font-size: 18px;"><a href="../../../../pages/bio/jjwt.html">Jayson Wynne-Thomas</a></p>
      <p style="font-size: 14px; text-align: right;"> 
        Last modified <span id="last_modified"></span>.</br>
        <script>
        var d = new Date(document.lastModified);
        document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
      </p>
    </header>
  </div>
  
  <div id="main" class="sidebar1">
    <span style="font-size:10px;cursor:pointer" onclick="openNav()">&#9776;</span>
  </div>

  <div id="mySidenav" class="sidebar">
  
<a href="#0">Topics</a>
<a href="#1">Overview</a>
<ul class="no-bullets">
  <li><a href="#1.0">Basic strategy</a></li>
</ul>
<a href="#2">Frames for pick and place</a>
<ul class="no-bullets">
  <li><a href="#2.0">Timing between key frames</a></li>
</ul>
<a href="#3">Interpolation between poses</a>
<ul class="no-bullets">
  <li><a href="#3.0">Interpolation between positions</a></li>
  <li><a href="#3.1">Problems faced when interpolating between orientations</a></li>
  <li><a href="#3.2">The right way to interpolate between orientations</a></li>
</ul>
</div>

<chapter style="counter-reset: chapter 3"><h1>Arm kinematics</h1>

<section id="0"><h1>Topics</h1>
  <ul>
    <li><a href="notations.html">Notations</a></li>
    <li><a href="spatialVelocity.html">Spatial Velocity</a></li>
    <li><a href="fk.html">Forward Kinematics</a></li>
  </ul>
</section>

<section id="1"><h1>Overview</h1>
  <ul>
    <li>Getting the notations right</li>
    Even in deep neural networks (say to calculate pose estimation), we're going to have a kinematics problem at some point and we're going to have a bug where the vectors are pointing the wrong way etc. If we get the notations right, spatial algebra will protect us.

    <p>
      <li>Choosing our frames</li>
      We have a gripper and a gripper frame; an object and an object frame. To grasp, we need to get the gripper frame in the right relative orientation and position to the object frame. 
    </p>

    <li>Trajectory generation</li>
    We'll plot the frames (the sketch) for the open-loop trajectory with the aim of the gripper picking up and dropping off a brick at a desired location. We forget the rest of the robot and just decide the different trajectory of poses the hand needs to go through in space at different timestamps; and then fill it out with interpolation.

    <p>
      <li>Inverse kinematics</li>
      We map the gripper plan sketch to moving the whole arm.
    </p>
  </ul>

  <subsection id="1.0"><h1>Basic strategy</h1>
    We have designed the gripper poses as a function of time using a trajectory generator and our aim is obtain corresponding joint positions as a function of time:

    $$
      X^G(t) \rightarrow q(t)
    $$

    The controller takes joint positions as input so we need to go from EE coordinates to joint commands. We start with a $q(0)$ and integrate forward using the joint velocity for that instant. The joint velocity is obtained by taking the inverse jacobian of the spatial velocity:

    $$
      \dot{q}(t) = [J^G(q)]^{-1}V^G(t)
    $$
    $V^G(t)$ is the spatial velocity of the gripper as a function of time.

    <p>
      We need to make sure the matrix is invertible or address it with more sophisticated methods. But intuitively we're going to design controllers that use the derivative of the kinematics (jacobian is approximately the derivative of FK) to get the smoothness in joint position transitions from one time instant to the next. 
    </p>

    We want to convert the smooth trajectory in EE coordinates to a smooth trajectory in the joint space, avoiding kinematic sigularities.

    <p>
      Summary: Use the reference trajectory to get $V_G$. Use Jacobian to get $\dot{q}$ which helps us to get $q(t)$ (integrating our way from q(0)) which is fed in as input. We need to avoid singularities by ensuring the Jacobian is invertible.
    </p>
  </subsection>
</section>

<section id="2"><h1>Frames for pick and place</h1>
  <table class="table1 center">
    <tr>
      <th>Object frames</th>
      <th>Gripper frames</th>
    </tr>
    <tr>
      <td>$O_{initial}$, $O_{goal}$</td>
      <td>$G_{initial}$, $G_{pick}$
        <br>
        $G_{prepick}$, $G_{postpick}$
        <br>
        $G_{place}$
        <br>
        $G_{preplace}$, $G_{postplace}$
        <br>
        $G_{clearance}$</td>
    </tr>
  </table>

  The numerical representation for a frame, say $O_{initial}$ on disk is its pose -  $^WX^{O_{initial}}$. A frame defines the semantics of whether we can connect 2 poses. But a pose is the manifestation that holds the position and orientation of a frame relative to some other frame. A frame cannot be represented because we have to somehow make a pose relative to something else.

  <p>
    Representing the pose of an object relative to the gripper or vice-versa is the most simple/robust representation commonly used for picking an object.
  </p>

  We interpolate from some initial gripper pose to a pose with the right clearance above the object to guarantee any collision is avoided. People do lots of interesting complicated algorithms to figure out how to move through space and just hand code the last movement often to avoid collision. 

  <p>
    To define the position of the gripper to move into to pick an object, pick whatever direction (in terms of axis) is the easiest relative to the object. A similar thinking applies to orientation. For this, it would be good to know what orientation the object is in. For a little red cube, it is hard to get its orientation from a perception system because it's symmetric. Then we get our pose $^{G_{pick}}X^{O_{initial}}$. We do the same for pre/post pick etc.
  </p>

  <subsection id="2.0"><h1>Timing between key frames</h1>
    Sometimes the time to finish a segment between going from 1 key frame to another, is absolute. Sometimes, it's scaled based on the distance between the frames. 
  </subsection>
</section>

<section id="3"><h1>Interpolation between poses</h1>
  We need to interpolate between the key poses to figure out where the gripper needs to be at all times between the pick and place frames.

  <subsection id="3.0"><h1>Interpolation between positions</h1>
    <p>
      Say, we had the following plot:
      <ul>
        <li>X-axis: time.</li>
        We can specify when the pick and place should take place and all the other intermediate frames specified in time.

        <p>
          <li>Y-axis: ${^WP^G_{W_x}}$</li>
          The position of the gripper in the world frame is a 3 element vector but we only consider the x component.
        </p>
      </ul>
    </p>

    <div class="container">
      <figure>
        <img style="height:80px; width:auto"
        src="../../../../figures/manipulation/39a_positionInterpolation.png"/>
        <figcaption>
          Key frames between pick and place times
        </figcaption>
      </figure>
      <figure>
        <img style="height:80px; width:auto"
        src="../../../../figures/manipulation/39b_positionInterpolation.png"/>
        <figcaption>
          First order interpolation
        </figcaption>
      </figure>
      <figure>
        <img style="height:80px; width:auto"
        src="../../../../figures/manipulation/39c_positionInterpolation.png"/>
        <figcaption>
          Zero order hold
        </figcaption>
      </figure>
    </div>

    There are different ways of interpolating:
    <ul>
      <li>First order hold</li>
      It's called first order because the line joining 2 points has 1DOF i.e. the slope of the line. It's a simple straight line interpolation. Doing a first order interpolation for orientation requires a bit more care compared to doing it for positions.

      <p>
        <li>Zero order hold</li>
        Zero order hold would be if there was no interpolation between the points and we just did some staircase. It is not safe to run this on a robot.
      </p>
      
      <li>Higher order interpolations</li>
      They give nice curves between key poses.
    </ul>
  </subsection>
  
  <subsection id="3.1"><h1>Problems faced when interpolating between orientations</h1>
    <subsubsection><h1>Choice of representation</h1>
      Some representations look simple to interpolate but then would blow up - could potentially go through bad states in the middle. 

      <p>
        There are roll pitch yaw values that represent very similar orientations but are actually very far in the values. Trying to go between one and another representation of roll pitch yaw might take the robot through extremely large numbers. This goes along with gimbal lock. 
      </p>
    </subsubsection>

    <subsubsection><h1>Simple linear interpolation for orientations is not possible</h1>
      Let's take a simple 2D rotation matrix example. We have a 2D rotation written as a function of some angle $\theta$ which will rotate a $2 \times 1$ vector by $\theta$ degrees:
      $$
        R(\theta) = \begin{bmatrix}
        c\theta & -s\theta \\
        s\theta & c\theta
        \end{bmatrix}
      $$

      Let's say we have 2 rotation matrices for rotating by $90^0$ and the other by $0^0$.
      $$
        R(0) = \begin{bmatrix}
        1 & 0 \\
        0 & 1
        \end{bmatrix} \quad
        R(\frac{\pi}{2}) = \begin{bmatrix}
        0 & -1 \\
        1 & 0
        \end{bmatrix}
      $$

      <div class="container">
        <figure>
          <img style="height:80px; width:auto"
          src="../../../../figures/manipulation/40a_0rotation.png"/>
          <figcaption>
            Rotation of a unit frame <code>Rotz(0)</code>
          </figcaption>
        </figure>
        <figure>
          <img style="height:80px; width:auto"
          src="../../../../figures/manipulation/40b_90rotation.png"/>
          <figcaption>
            Rotation of a unit frame <code>Rotz(90)</code>
          </figcaption>
        </figure>
      </div>
      If we were to linearly interpolate between the 2 angles, we wouldn't get $45^0$ i.e. we'd get $\frac{1}{2}$s in the rotation matrix instead of $\frac{1}{\sqrt{2}}$s. We can't just interpolate orientations.
    </subsubsection>

    <subsubsection><h1>Why don't we have such problems with angular velocities</h1>
      Angles wrap around every $2\pi$ and velocities don't. If we rotate by $\pi$, $-\pi$ or $3\pi$, we'll end up at the same place. But $100rad/s$ is still different than every other positive radian per second.

      <p>
        In 2D, you can represent everything with a scalar, a single rotation. When the wrapping effect is seen, flip back from polar coordinates or rectangular coordinates and we can always figure out the angles between two locations. In 2d, if we think about a rotation taking us around a unit sphere - a point moving around the unit sphere, the angular velocity is just the tangent on that and it's well behaved.
      </p>
 
      In 3d, there are rotations/angles that we can get to from many paths and picking a unique inverse of it is messy. 
    </subsubsection>
  </subsection>

  <subsection id="3.2"><h1>The right way to interpolate between orientations</h1>
    People typically use:
    <ul>
      <li>The quaternion representation to get around gimbal lock</li>
      <li><i>SLERP (Spherical linear interpolation)</i> to get a smooth first order interpolation</li>
    </ul>
  </subsection>

</section>

</chapter>

</body>
</html>
