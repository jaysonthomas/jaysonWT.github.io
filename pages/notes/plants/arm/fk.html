
<!DOCTYPE html>
<html>
<head>
  <title>Basics of pick and place</title>
  <meta name="Basics of pick and place" content="text/html; charset=utf-8;" />
  <script type="text/javascript" src="../../../logbook.js"></script>

  <script src="../../../logbook-mathjax-config.js" defer></script> 
  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" type="text/css" href="../../../logbook.css" />
</head>

<body onload="loadChapter('');">  

  <div data-type="titlepage" pdf="no">
    <header>
      <h1><a href="../../../index.html" style="text-decoration:none;">Logbook</a></h1>
      <p style="font-size: 18px;"><a href="../../../pages/bio/jjwt.html">Jayson Wynne-Thomas</a></p>
      <p style="font-size: 14px; text-align: right;"> 
        Last modified <span id="last_modified"></span>.</br>
        <script>
        var d = new Date(document.lastModified);
        document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
      </p>
    </header>
  </div>
  
  <div id="main" class="sidebar1">
    <span style="font-size:10px;cursor:pointer" onclick="openNav()">&#9776;</span>
  </div>

  <div id="mySidenav" class="sidebar">
  
<a href="#0">Overview</a>
<ul class="no-bullets">
  <li><a href="#0.0">Basic strategy</a></li>
</ul>
<a href="#1">Notations</a>
<ul class="no-bullets">
  <li><a href="#1.0">Frames</a></li>
  <li><a href="#1.1">Position</a></li>
  <li><a href="#1.2">Orientation</a></li>
  <li><a href="#1.3">Pose</a></li>
  <li><a href="#1.4">Notation understanding check</a></li>
  <li><a href="#1.5">Example usage</a></li>
</ul>
<a href="#2">Frames for pick and place</a>
<ul class="no-bullets">
  <li><a href="#2.0">Timing between key frames</a></li>
</ul>
<a href="#3">Interpolation between poses</a>
<ul class="no-bullets">
  <li><a href="#3.0">Interpolation between positions</a></li>
  <li><a href="#3.1">Problems faced when interpolating between orientations</a></li>
  <li><a href="#3.2">The right way to interpolate between orientations</a></li>
</ul>
<a href="#4">Forward kinematics problem</a>
<ul class="no-bullets">
  <li><a href="#4.0">Description</a></li>
  <li><a href="#4.1">Computing the pose of the EE using FK</a></li>
  <li><a href="#4.2">Defining $q$</a></li>
  <li><a href="#4.3">Drake implementation</a></li>
</ul>
<a href="#5">Inverse kinematics</a>
<a href="#6">Differential IK</a>
<ul class="no-bullets">
  <li><a href="#6.0">Description</a></li>
  <li><a href="#6.1">Spatial velocity</a></li>
  <li><a href="#6.2">Geometric jacobian</a></li>
  <li><a href="#6.3">Joint velocity</a></li>
  <li><a href="#6.4">Inverse Jacobian</a></li>
</ul>
<a href="#7">The controller</a>
<ul class="no-bullets">
  <li><a href="#7.0">Limitations</a></li>
</ul>
<a href="#8">Singularities</a>
<a href="#9">Differential IK as optimisation</a>
<a href="#10">Summary of the usefulness of optimisation</a>
<a href="#11">Example</a>
<a href="#12">Closing remarks</a>
<ul class="no-bullets">
  <li><a href="#12.0">QP formulation 1</a></li>
  <li><a href="#12.1">QP formulation 2</a></li>
  <li><a href="#12.2">Comparison of the 2 formulations</a></li>
</ul>
</div>

<chapter style="counter-reset: chapter 3"><h1>Arm: Forward Kinematics</h1>

<section id="4.0"><h1>Description</h1>
  $$
    X^B = f^B_{kin}(q)
  $$  

  In this mathematical equation (actual implementation in code is different):
  <br>
  $q$ is the vector of positions.
  <br>
  $X$ is the pose in the world.
  <br>
  $f_{kin}$ is the FK of the body.
  <br>
  $B$ stands for body.
  <br>
  $G$ stands for gripper if it was used instead of $B$.    
  
  <p>
    The mapping from joint angles to poses is called the <i>Forward Kinematics problem</i>. Looking at the 2D rotation matrix above:
    $$
      R(\theta) = \begin{bmatrix}
      c & -s \\
      s & c     
      \end{bmatrix}
    $$
  </p>

  If we have joint angle $\theta$ and we want to turn it into a rotation or a pose then it is almost always going to be a nonlinear map from the joint angles into the poses. The matrix above is maybe the simplest example of it.
</section>

<section id="4.1"><h1>Computing the pose of the EE using FK</h1>
  Given that we've set all the joint angles:
  <ul>
    <li>Compute pose of the EE relative to the wrist</li>
    We find the rotation matrix for the rotation joint which is just a relative pose.

    <p>
      <li>Chain it backwards all the way to the world coordinates</li>
    </p>
  </ul>

  The math is simple because each individual joint is just describing a small rotation matrix kind of operation on a relative transform from right before the robot's joint until right after the robot's joint. That's how robots are specified in robot description files as relative poses of each link - 6 numbers: x, y, z, roll, pitch, yaw. Joints are just operations that will make a transformation from the pre joint frame to the post-joint frame. 

</section>

<section id="4.2"><h1>Defining $q$</h1>
  <p>
    $q$ should be defined in such a way so as to be sufficient to tell us where all the attached bodies are in the world. In iiwa that's bolted down, all we need are 7 numbers of the different rotations of the different joints. But if we have a red brick on the table, we need enough something in $q$ to be able to eventually pull out the pose. 
  </p>

  In code, we define a $3\times 3$ rotation matrix for each joint based on the corresponding joint angle. We can then go through a series of frame transformations (through all the joints) to get the full kinematics. 
  <ul>
    <li>Iiwa</li>
    In iiwa, it's a $7\times 1$ vector of rotational joint angles representing the revolute joints. It's 7 because we choose to use quaternions in the coordinate representation to avoid gimbal locks and singularities.

    <p>
      <li>Allegro hand</li>
      It has 4 fingers with 4 links per finger. Total number of joint angles is 16. Plus, 7 numbers to configure its position in space. 
    </p>

    <li>Allegro hand picking up a brick</li>
    23 numbers for the hand and 7 for the brick. The kinematics problem then becomes going from the 30 numbers (representing q) to some pose of the brick and hand.
  </ul>
</section>

<section id="4.3"><h1>Drake implementation</h1>
  To compute the FK in drake, we need to specify the frames to get the pose of the desired frame relative to some other frame expressed in some other frame.

  <p>
    The context is taken as the argument instead of $q$ because the kinematics can be parameterized. If we were designing a robot and we wanted to optimise the length of a link for instance. Then we'd like the kinematics to also be a function of the link lengths or some other quantities. Hence, this is useful.
  </p>

  The <i>context</i> is just state + parameters + time; it's just the structure that wraps it. 

  <p>
    Very often, quaternions is used to represent the position/orientation and rotation matrix is used to represent the pose $X$.
  </p>
</section>

</chapter>
</body>
</html>
