
<!DOCTYPE html>
<html>
<head>
  <title>Manipulator control</title>
  <meta name="Manipulator control" content="text/html; charset=utf-8;" />
  <script type="text/javascript" src="../../../logbook.js"></script>

  <script src="../../../logbook-mathjax-config.js" defer></script> 
  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" type="text/css" href="../../../logbook.css" />
</head>

<body onload="loadChapter('');">  

  <div data-type="titlepage" pdf="no">
    <header>
      <h1><a href="../../../index.html" style="text-decoration:none;">Logbook</a></h1>
      <p style="font-size: 18px;"><a href="../../../pages/bio/jjwt.html">Jayson Wynne-Thomas</a></p>
      <p style="font-size: 14px; text-align: right;"> 
        Last modified <span id="last_modified"></span>.</br>
        <script>
        var d = new Date(document.lastModified);
        document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
      </p>
    </header>
  </div>
  
  <div id="main" class="sidebar1">
    <span style="font-size:10px;cursor:pointer" onclick="openNav()">&#9776;</span>
  </div>

  <div id="mySidenav" class="sidebar">
  
<a href="#0">Overview</a>
<a href="#1">Stiffness control implemented using feedback cancellation</a>
<ul class="no-bullets">
  <li><a href="#1.0">Example: Double pendulum - joint stiffness control</a></li>
  <li><a href="#1.1">Benefit of having gravity compensation</a></li>
</ul>
<a href="#2">Joint impedance control</a>
<ul class="no-bullets">
  <li><a href="#2.0">Example: Iiwa</a></li>
  <li><a href="#2.1">Example: Opening a dishwasher door</a></li>
</ul>
<a href="#3">Stiffness control in end-effector coordinates</a>
<ul class="no-bullets">
  <li><a href="#3.0">Change of coordinates</a></li>
  <li><a href="#3.1">Is (\ref{eq:opSpaceForm}) invertible?</a></li>
  <li><a href="#3.2">Null space of the controller (\ref{eq:resultOpSpaceForm})</a></li>
</ul>
<a href="#4">Side notes</a>
<a href="#5">Questions & todo</a>
</div>

<chapter style="counter-reset: chapter 3"><h1>Manipulator control</h1>

<section id="0"><h1>Overview</h1>
  In <a href=lecture2021ForceControl.html>force control</a>, the robot was assumed to be a point. Here, the whole robot is considerd focusing on the force control aspects of manipulator control. 

  <p>
    For the pushing-a-book-on-a-table task, there is a sweet spot where the right amount of force needs to be applied to maintain frictional contact between the hand and the book so that the hand doesn't slide away on the book; but the downward force cannot be too high preventing the book from being able to slide on the table.
  </p>
</section>

<section id="1"><h1>Stiffness control implemented using feedback cancellation</h1>
  Locally, within reason, if we want to change our dynamics a bit then 
  feedback cancelling control is an incredibly practical powerful idea.
  Inspired by the force cancellation philosophy, our goal is to make the big complicated 
  robot act like it's a point robot at the end such that we can apply forces or 
  program the interaction at the end. 

  <p>
    Let's generalise or implement a version of this idea to make a robot arm act 
    like a stiffness controller. So if we want to program the interactions, we'll 
    start by programming them at the joint level. Instead of having the DP act like a 
    simple pendulum, let's make it act like a system such that when it is pushed 
    it has some desired mechanical response. 
  </p>

  <subsection id="1.0"><h1>Example: Double pendulum - joint stiffness control</h1>
    There's a bunch of different controllers we could write here - torque control and 
    position control. If we were to write a position controller for this we might write a 
    PD control:
    $$\begin{equation}
      u = K_p(q^d-q) - K_d(\dot{q}^d-\dot{q})
    \end{equation}$$

    The philosophy in stiffness control though is not to have just a rigid position 
    but to actually program the response. We want the pendulum to not act like a simple 
    pendulum but like a different mechanical system which has a particular response to 
    torque perturbations. Say, we'd like it to act like a pendulum that has some rotary 
    springs at joint 2 of a certain stiffnes $k$, and maybe some damping.

    <p>
      The goal is for the system to have the following behaviour/interaction:
      $$\begin{equation}
        M(q)\ddot{q} + C(q,\dot{q}) + K_p(q-q^d) + K_d(\dot{q}^d-\dot{q}) = \tau_{ext}
      \end{equation}$$

      The coordinates of this equation are in torques. If we push on the pendulum, i.e. 
      give a torque perturbation or if the arm runs into something  (we represent 
      this interaction in torque coordinates), we'd like it to respond gracefully as if 
      it were a <i>Mass-Spring-Damper</i> system (taught in 
      <a href="https://t.ly/wj9h">MIT 18.03</a>):
      $$\begin{equation}
        m\ddot{x} + b\dot{x} + kx = f
      \end{equation}$$ 

      (4) is the general form of which (3) is the joint version. In (3), the reason why
      we don't write the $K_p$ term as $-K_p(q^d-q)$ is because we want to think of the
      term as representing stiffness $kx$.
    </p>

    <p>
      Using the same philosophy from feedback cancellation, we can achieve our 
      goal controller (3) by:
      <ul>
        <li>Cancelling out the dynamics of the plant that we don't like and</li>
        The gravity compensation term $\tau_g$; we will keep the $M$ and $C$ terms.
        <li>Inserting the dynamics we do like</li>
        i.e. our PD control given in (2).
      </ul>   
      $$\begin{equation}
        u = -\tau_g(q) + K_p(q^d-q) - K_d(\dot{q}^d-\dot{q})
      \end{equation}$$
    </p>

    This control removes the effect of gravity (i.e. <i>gravity compensation</i>)
    and replaces it with the stiffness kind of interaction seen in (3). This type
    of control is called <i>stiffness control</i> or <i>simple impedance control</i>.
    <i>Impedance control</i> is the more general term for the whole set of concepts.
  </subsection>

  <subsection id="1.1"><h1>Benefit of having gravity compensation</h1>
    In practice, the difference in having a controller with just PD control and no 
    gravity compensation is huge. In DP, if we wanted to hold the pendulum in a horizontal 
    position (i.e. choose a stiffness that allows us to do that) where gravity is pulling down; 
    if we don't have GC, the $K_p$ term will need to do the work of cancelling out gravity and 
    hence will have a large value.

    <p>
      If we want to hold the DP at an offset from the horizontal position, we would still 
      need to keep $K_p$ very large in the PD controller. If the DP were in the downward 
      position, we wouldn't have required a large $K_p$ to get a reasonable performance 
      compared to the horizontal position. But, we end up with an excessive value all over
      the workspace.
    </p>

    So, if we want reasonable performance all over the state space with just a 
    PD controller, we have to choose $K_p$ to be very large and $K_d$ to be very large 
    as well just to damp the effect of having a large $K_p$ term. If we subtract out gravity 
    i.e. we use GC in our controller, then we can choose $K_p$, $K_d$ to be much lower 
    and we can be much more responsive. In practice when people are running controllers 
    without GC and we bump into the robot, 
    it may trigger a fault and power down. If we do it with GC, it will be soft enough 
    to get out of the way.


  </subsection>
</section>

<section id="2"><h1>Joint impedance control</h1>
  We chose our desired dynamics to use the initial mass and coriollis terms. $M$ and $C$ 
  always go together (even in reality). We chose not to change them. Think of them as 
  $ma$ in $F=ma$. It typically requires high bandwidth to cancel out $M$ and $C$ and 
  to achieve good accuracy of our mass. When we decide to change $M$ and $C$, 
  the control method is called <i>joint impedance control</i>.

  <subsection id="2.0"><h1>Example: Iiwa</h1>
    In reality, compared to (5), Iiwa does much more than just GC. 
    When we run iiwa in joint-impedance control mode, it also does 
    friction compensation and some subtle stuff at the actuator level to cancel out the 
    effective dynamics of the arm.  

    <p>
      It does some amount of mass cancellation but actually it only compensates for the 
      masses of the rotors and not for the whole robot. It's actually a very subtle, carefully 
      designed control - they are technically changing $M$, $C$ a little bit but not in the way 
      of making a different effective mass. It's very similar to the feedback cancellation 
      story but it's trying to do a little bit less (because it's not cancelling $M$,$C$ of 
      the whole robot) and it's even more robust because of it.
    </p>
  </subsection>

  <subsection id="2.1"><h1>Example: Opening a dishwasher door</h1>
    <p>
      The joint trajectory that iiwa is programmed to follow during the opening motion 
      is going to deviate significantly depending on how accurately we have modelled and 
      captured the location of the dishwasher door. Even to open the hinge of the dishwasher, 
      we can imagine that if we're trying to move down exactly based on some kinematic 
      constraint given by the door of the dishwasher, if we're a little bit off (i.e. the 
      door doesn't open the way we thought it would or the door handle isn't where we thought 
      it would be) then it pays a lot to be flexible enough to just follow whatever contour 
      is given by the actual position of the dishwasher and not by our course approximation.
    </p> 

    <p>
      Whilst opening the door, our fingers will slip off if we're in too stiff of a mode. 
      Similarly when we push down on the door (to lay it flat when open) it's still in a 
      joint impedance mode and it's not tracking the position trajectory super accurately 
      but it's accomplishing the task. 
    </p>
  </subsection>
</section>

<section id="3"><h1>Stiffness control in end-effector coordinates</h1>
  How do we go from implementing the controller at the joints to implementing it just 
  at the end effector? So instead of affecting the dynamics in $q$ we want to write 
  the dynamics at the EE. We want the fingertip to act like a MSD.

  <p>
    This is sometimes also called <i>cartesian/EE stiffness control</i>. So how do we 
    take those basic equations and impose a dynamics in the EE. We have the end position 
    of the arm given by some kinematic function of $q$: 
    $$
      p^c = f_{kin}(q)
    $$
    The end contact point is determined by the joint angles. This is the relationship 
    we get to work with and we would like to impose/achieve the following goal:
    $$\begin{equation}
      m\ddot{p}^c + b\dot{p}^c + k(p^c-p^{c_d}) = f^c_{ext}
    \label{eq:goal2}
    \end{equation}$$
  </p>

  <subsection id="3.0"><h1>Change of coordinates</h1>
    We have our joint angles in $q$ coordinates and we have to somehow change to $p$
    coordinates in order to achieve our goal. 

    <p>
      It's very easy in the derivation (starting from the initial eqs.) to end up at a dead end. 
      But the following method which uses the right way to change coordinates 
      (i.e. using the Jacobian) will get us there:
    </p>
    <equation><h1>The right way to change from joint to position coordinates</h1>
      $$\begin{equation}
        M_c(q) = (J^c(q)M^{-1}(q)J^{c^T}(q))^{-1}
      \label{eq:opSpaceForm}
      \end{equation}$$
      $M_c$ is the EE mass or the effective mass.
      <br>
      $M$ is the mass of the original system.
      <br><br>

      This transformation is often called <i>operation space form of the dynamics</i>. 
      Super useful! 
      It's not surprising that we use the Jacobian to change coordinates.
      The Jacobian $J^c(q)$ is given by:
      $$
        \dot{p}^c = J^c(q)\dot{q}
      $$
      Looking at (\ref{eq:opSpaceForm}), what's maybe a little surprising is that we can 
      write the equations of 
      motion in the EE frame as a function of the original coordinates and the Jacobian.
    </equation>

    We get a new set of equations with an altered mass matrix, an altered coriolis matrix 
    on the LHS (which still depends on $q$ and $\dot{q}$), an altered torque matrix 
    ($F$) plus $u$ in the new coordinates plus external forces. 
    $$\begin{equation}
      M_c(q)\ddot{p}^c + C_c(q,\dot{q}) = F^c_g(q) + u_c + f^c_{ext}
    \label{eq:resultOpSpaceForm}
    \end{equation}$$

    (\ref{eq:opSpaceForm}) was the magic step we needed. Now if we start working with 
    the new dynamics (\ref{eq:resultOpSpaceForm}) in the operation/EE space then we can 
    just do feedback cancellation in this lower space.
  </subsection>

  <subsection id="3.1"><h1>Is (\ref{eq:opSpaceForm}) invertible?</h1>
    What are the conditions that would be required for the matrix in (\ref{eq:opSpaceForm}) 
    be invertible? 

    <p>
      In general we'd expect $(AA^T)^{-1}$ to exist if $A$ has full row rank. 
      So let's first ask does the Jacobian have full row rank? We can certainly find 
      singular configurations where it doesn't (when the arm is stretched out). 
      But in all reasonable parts of the workspace, $J$ tends to be. 
      For instance it could be: $J(q)=3\times nq$ if we're trying to do EE stuff; 
      it tends to be full row rank and low column rank because it's a long short matrix. 
      The mass matrix is positive definite so that is going to be well conditioned too.
    </p>

    So, the matrix should have an inverse as long as $J$ doesn't go singular; which is as 
    it should be intuitively. If we just try to start jamming $J$ transpose in our EoM
    we'll get stuck. But it must be the case that if we were to push on the EE of a 
    physical contraption it will push back on us with some physical force. The force that 
    it pushes back with is configuration (LHS of (\ref{eq:resultOpSpaceForm})) dependent 
    - there will be some big complicated set of mass which will more or less work 
    against me in each axis depending on the configuration of the mass.

    <p>
      What is the ability of the arm to produce force at the EE in a singular configuration? 
      The controller can't produce force in the direction the arm is stretched out 
      instantaneously but it can produce a forced dot. So we have to be careful if we start 
      writing controllers similar to (\ref{eq:resultOpSpaceForm}) in such singular 
      configurations - people tend to write it in a constrained least squares form and 
      put some boundaries on it. Try not to take the inverse of the Jacobian as in 
      (\ref{eq:opSpaceForm}) in singular conditions or be careful about it. 
    </p>
  </subsection>

  <subsection id="3.2"><h1>Null space of the controller (\ref{eq:resultOpSpaceForm})</h1>
    If we write a controller that tells the robot to act like a certain dynamics in the 
    xyz configuration, but say the robot has 7 DOF, then we've still got to specify 
    something for the joints (so that the joints don't get into an odd configuration and 
    bump somewhere for example). The same way in our Jacobian based controller, we talked 
    about putting a secondary objective in the null space (something for instance to stay 
    in a comfortable joint configuration, example: EE position is fixed, but joints are moving) 
    we need to do something similar to stabilise the null space of this controller too.

    <p>
      So choose $u_c$ such that (\ref{eq:resultOpSpaceForm}) almost 
      equals (\ref{eq:goal2}):

      $$
        M_c(q)\ddot{p}^c + C(q, \dot{q}) + K_p(p^c - p^{c^d}) + .. = 
      $$
      And I think, also add in nullspace stabilisation to the mix.
    </p>

    The fact that we tend to not change $M$, $C$ and that they are configuration dependent, 
    means that, instantaneously, we can make our robot act like a MSD system. The mass 
    that it acts like though will be configuration dependent. Almost always! In the 
    quasi-static analysis case, if the accelerations are small, if we're going to push 
    and see how far the robot deflects (i.e. how much we can push it) before it hits a 
    new steady state and stops, the mass doesn't matter there; the inertial terms 
    don't matter in the static analysis. But in the dynamic analysis, if we start trying to 
    understand the dynamics of our robot then $M$ and $C$ are going to be notable; 
    maybe not hugely important. It would be beautiful and clean to make them somehow constant, 
    a function of $q$ but we tend to not do that. There are theoretical limits on how 
    much we can change the mass before we write a controller that is unstable. 
    Neville Hogan has some great surveys on that.
  </subsection>
</section>

<section id="4"><h1>Side notes</h1>
  The papers on how control is implemented in Iiwa are great. They are linked in the notes.
  <ul>
    <li>Abu Ahafer and Christian Ott about impedance control of elastic joint robots</li>
    <li>Alessandro de Luca has some great notes too</li>
    <li>Mark Spong did some early work</li>
  </ul>
</section>

<section id="5"><h1>Questions & todo</h1>
  <ul>
    <li>
      I think the code to turn a DP into a single one is 
      <code>intro.ipynb</code> </li>
    <li>
      Search for impedance in <a href="https://t.ly/knLC">this chapter</a>.
      Also, joint-stiffness control. Also, there is documentation referenced on how
      iiwa is implemented.
    </li>

    <p>
      <li>What does it mean for a Jacobian matrix to be full row rank?</li>
      What does it mean physically for a matrix to be full row rank?
    </p>

    <li>
      What does stabilise the nullspace jacobian mean?
      <a href="https://t.ly/U48b">This</a> could be helpful.
    </li>
  </ul>
</section>

</chapter>

</body>
</html>
