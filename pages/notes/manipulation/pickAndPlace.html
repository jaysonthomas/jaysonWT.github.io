
<!DOCTYPE html>
<html>
<head>
  <title>Basics of pick and place</title>
  <meta name="Basics of pick and place" content="text/html; charset=utf-8;" />
  <script type="text/javascript" src="../../../logbook.js"></script>

  <script src="../../../logbook-mathjax-config.js" defer></script> 
  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" type="text/css" href="../../../logbook.css" />
</head>

<body onload="loadChapter('');">  

  <div data-type="titlepage" pdf="no">
    <header>
      <h1><a href="../../../index.html" style="text-decoration:none;">Logbook</a></h1>
      <p style="font-size: 18px;"><a href="../../../bio/jjwt.html">Jayson Wynne-Thomas</a></p>
      <p style="font-size: 14px; text-align: right;"> 
        Last modified <span id="last_modified"></span>.</br>
        <script>
        var d = new Date(document.lastModified);
        document.getElementById("last_modified").innerHTML = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate();</script>
      </p>
    </header>
  </div>

  <table style="width:100%;" pdf="no"><tr style="width:100%">
    <td style="width:33%;text-align:left;">
      <a class="previous_chapter" href="">Prev Chapter</a>
    </td>
    
    <td style="width:33%;text-align:center;">
      <a href="">Root Chapter</a>
    </td>
    
    <td style="width:33%;text-align:right;">
      <a class="next_chapter" href="">Next Chapter</a>
    </td>
  </tr></table>
  
  <div id="main" class="sidebar1">
    <span style="font-size:10px;cursor:pointer" onclick="openNav()">&#9776;</span>
  </div>

  <div id="mySidenav" class="sidebar">
  
<a href="#0">Overview</a>
<a href="#1">Notations</a>
<ul class="no-bullets">
  <li><a href="#1.0">Position</a></li>
  <li><a href="#1.1">Orientation</a></li>
  <li><a href="#1.2">Pose</a></li>
  <li><a href="#1.3">Example usage</a></li>
</ul>
</div>

<chapter style="counter-reset: chapter 3"><h1>Basics of pick and place</h1>

<section id="0"><h1>Overview</h1>
  <ul>
    <li>Getting the notations right</li>
    Even in deep neural networks (say to calculate pose estimation), we're going to have a kinematics problem at some point and we're going to have a bug where the vectors are pointing the wrong way etc. If we get the notations right, spatial algebra will protect us.

    <p>
      <li>Choosing our frames</li>
      We have a gripper and a gripper frame; an object and an object frame. To grasp, we need to get the gripper frame in the right relative orientation and position to the object frame. 
    </p>

    <li>Trajectory generation</li>
    We'll plot the frames for the open-loop trajectory of the gripper picking up and dropping off the brick at the desired location.

    <p>
      <li>Inverse kinematics</li>
      We map the gripper plan sketch to moving the whole arm.
    </p>
  </ul>
</section>

<section id="1"><h1>Notations</h1>
  <subsection id="1.0"><h1>Position</h1>
    The simplest concept is just a point in some three-dimensional space. 
    <ul>
      <li>$A$ is the frame or point of interest</li>
      <li>$P^A$ - Position of $A$</li>
      <p>
        <li>$^BP^A$ - Position of $A$ relative to $B$</li>
        $P$ is a vector going from point $B$ to $A$ - Imagine an arrow drawn from $B$ to $A$. Positions always have to be defined w.r.t. something.
      </p>
      <li>$\in\mathbb{R}^3$</li>
      Our 3D vectors (3x1) contain 3 real numbers.
      <p>
        <li>$^BP^A_C$ - $C$ is the expressed in frame</li>
        Distance between 2 people is given by $P$. But if we turn our back, the vector between the 2 points is still the same, but now they'll be expressed using different numbers w.r.t. me looking the other way.
      </p>
    </ul>

    A <i>reference frame</i> has a point at its centre. Its orientation can be represented in many ways but it is visually represented with the xyz axes. XYZ => RGB. Use the <a href="https://bit.ly/3FdV8Sl">right-hand rule</a> (vehicle coordinate system). 

    <p>
      We'll have lots of frames. Our aim will be to get the frames to match; because once they do, the algebra becomes trivial. For example, once the frames match, we can add positions.

      <div class="container">
        <figure>
          <img style="height:60px; width:auto"
          src="../../../figures/manipulation/34_vectorAddition.png"/>
          <figcaption>
            $^BP^E_C = ^BP^A_C + ^AP^E_C$
          </figcaption>
        </figure>
      </div>
    </p>
    Another example, inverse flips the sign: $-^BP^A_C = ^AP^B_C$
  </subsection>

  <subsection id="1.1"><h1>Orientation</h1>
    There are a number of ways to represent the relative orientation: 
    <ul>
      <li>Rotation matrix</li>
      <li>Euler angles of which there are many but the familiar ones are roll pitch yaw</li>
      <li>Quaternions</li>
    </ul>
    There are functions that let us go back and forth in between them.  Unfortunately there's no one representation to rule them all. Different parts of the stack will use different representations. But in the spatial algebra we call the whole thing $R$. Orientation of $A$ relative to $B$:  
    $$^BR^A$$ 
    
    This orientation can be represented in any of the above formats, but we'll still call it $R$ for the actual purposes of the algebra. For orientations, we use the multiplication operator instead of the addition operator: 
    $$
      ^BR^A \cdot ^AR^C = ^BR^C
    $$

    Orientations don't need an expressed-in frame. We can turn our head however we want or change the current frame, but the rotation of $A$ relative to $B$ will still be the same. Just like we had an additive inverse for addition we have a multiplicative inverse for rotations/orientations:
    $$
      [^BR^A]^{-1} = ^AR^B
    $$ 

    If we think about $R$ as a rotation matrix, then the inverse is just the matrix inverse and life is good. We've abstracted away from the underlying numerical representation. We're just talking about the ability to go back and forth between rotations. It happens that if we have a 3x3 rotation matrix representing the orientation, then because rotation matrices are orthonormal, the transpose is the same as the inverse. 
  </subsection>

  <subsection id="1.2"><h1>Pose</h1>
    The position and orientation of a frame, put together, is called the <i>pose</i> of the frame:
    $$
      ^BX^A
    $$
    
    This is the position and orientation of frame $A$ relative to the position and orientation of frame $B$. In Drake, <n>pose is the noun and transform is the verb</n>. (We need an expressed-in frame for the pose because of the position part.)

    <p>
      $P^A$ is the same as $^WP^A_W$. In drake visualisations, an RGB axis at the origin defines the world axis. If the expressed-in frame is not specified, it should be assumed that:
      $$^GP^A \equiv {^GP^A_G}$$ 
    </p>

    $$\begin{align*}
      ^GP^A &= ^GX^F \cdot {^FP^A} \\
            &= (^GP^F \cdot {^GR^F}) \cdot {^FP^A} \\
            &= (^GP^F_G \cdot {^GR^F_G}) \cdot {^FP^A} \\
    \end{align*}$$

    If these were all expressed in different frames, then it would not be a valid equation. The multiplication operator along with the rotation that is encoded in $X$ transforms the position of $A$ in the following way:
    <ul>
      <li>W.r.t. $F$ to another frame, w.r.t. $G$</li>
      <li>The expressed-in frame, from $F$ to $G$</li>
      <n>The basic operation of a rotation matrix is to take a position and change its expressed-in frame</n>.
    </ul>
    
    A pose also has a multiplicative inverse:  $[^GX^F]^{-1} = {^FX^G}$. A pose can be represented in different ways. This is only a notation indicating we are taking an inverse. But actually it's not just a direct matrix inverse - <m>it will be some simple function of the elements of the matrix representation</m>. A lot of times a pose is represented as a 3x4 matrix for instance.

    <p>
       Pose can also be called a <i>rigid transform</i> because it only allows changing between frames in the kinematics, i.e. only positions and rotations; no scaling or shearing. <i>Homogeneous transforms</i> also allow shearing and scaling.
    </p>

    Poses multiply with other poses. A set of rules are given in Chapter 3. <m>I should figure out <a href="https://bit.ly/3mJCHP6">this question</a></m>.
  </subsection>

  <subsection id="1.3"><h1>Example usage</h1>
    The is core to planning, perception, controls etc. If we had cameras mounted around a kuka, taking some depth measurements, trying to find out where things are in the scene. The data coming into each of those cameras are going to be in the associated camera's frame. For it to be usable, we'll have to convert it to a common representation - a common coordinate frame typically a world frame (or a gripper frame). The way we do that is by multiplying each camera's output by $X$. We can put them together if the frames match. 

    <div class="container">
      <figure>
        <img style="height:50px; width:auto"
        src="../../../figures/manipulation/35_notationUsage.png"/>
        <figcaption>
          Notation usage example in multi-camera scenario
        </figcaption>
      </figure>
    </div>
  </subsection>
</section>
</chapter>

</body>
</html>
